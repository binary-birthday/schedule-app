// Code generated by Prisma Client Rust. DO NOT EDIT

pub static DATAMODEL_STR: &'static str =
    include_str!("/home/thelostmachine/Projects/rust_projects/schdule-app/prisma/schema.prisma");
static DATABASE_STR: &'static str = "postgresql";
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
    url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder()
        .with_url(url.to_string())
        .build()
        .await
}
pub mod user {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "User";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod first_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "first_name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetFirstName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FirstName(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::FirstName(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::FirstName(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            FirstName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FirstName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FirstName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod last_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "last_name";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetLastName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::LastName(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::LastName(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::LastName(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            LastName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::LastName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::LastName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod phone {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "phone";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPhone(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Phone(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Phone(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Phone(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Phone,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Phone(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Phone(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod email {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "email";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetEmail(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Email(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Email(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::EmailEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Email,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Email(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Email(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod team_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "team_id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTeamId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TeamId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::TeamId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::TeamId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            TeamId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TeamId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TeamId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod team {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "team";
        pub struct Fetch(pub team::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<team::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Team(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(team::UniqueArgs::new())
        }
        pub struct Connect(team::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectTeam(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: team::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<team::WhereParam>) -> WhereParam {
            WhereParam::TeamIs(value)
        }
        pub fn is_not(value: Vec<team::WhereParam>) -> WhereParam {
            WhereParam::TeamIsNot(value)
        }
        pub enum Include {
            Select(Vec<team::SelectParam>),
            Include(Vec<team::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Team(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <team::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <team::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("team", None, [], selections)
            }
            pub fn select(nested_selections: Vec<team::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<team::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<team::SelectParam>),
            Include(Vec<team::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Team(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <team::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("team", None, [], selections)
            }
            pub fn select(nested_selections: Vec<team::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<team::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        id: String,
        first_name: String,
        email: String,
        team: super::team::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        super::team::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (id, first_name, email, team, _params)
    }
    pub fn create_unchecked(
        id: String,
        first_name: String,
        email: String,
        team_id: String,
        _params: Vec<SetParam>,
    ) -> (String, String, String, String, Vec<SetParam>) {
        (id, first_name, email, team_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: user :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: user :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: user :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: user :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , first_name , last_name , phone , email , team_id , team } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: user :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: user :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: user :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: user :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "first_name" , "last_name" , "phone" , "email" , "team_id" , "team"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: user :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; first_name) => { String } ; (@ field_type ; last_name) => { Option < String > } ; (@ field_type ; phone) => { Option < String > } ; (@ field_type ; email) => { String } ; (@ field_type ; team_id) => { String } ; (@ field_type ; team : $ selection_mode : ident { $ ($ selections : tt) + }) => { team :: Data } ; (@ field_type ; team) => { crate :: prisma :: team :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "User" , available relations are "id, first_name, last_name, phone, email, team_id, team")) } ; (@ field_module ; team : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: team :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: id :: Select) } ; (@ selection_field_to_selection_param ; first_name) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: first_name :: Select) } ; (@ selection_field_to_selection_param ; last_name) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: last_name :: Select) } ; (@ selection_field_to_selection_param ; phone) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: phone :: Select) } ; (@ selection_field_to_selection_param ; email) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: email :: Select) } ; (@ selection_field_to_selection_param ; team_id) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: team_id :: Select) } ; (@ selection_field_to_selection_param ; team $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: team :: Select :: $ selection_mode (crate :: prisma :: team :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; team $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: team :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; first_name) => { "first_name" } ; (@ field_serde_name ; last_name) => { "last_name" } ; (@ field_serde_name ; phone) => { "phone" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; team_id) => { "team_id" } ; (@ field_serde_name ; team) => { "team" } ; }
    pub use _select_user as select;
    pub enum SelectParam {
        Id(id::Select),
        FirstName(first_name::Select),
        LastName(last_name::Select),
        Phone(phone::Select),
        Email(email::Select),
        TeamId(team_id::Select),
        Team(team::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::FirstName(data) => data.to_selection(),
                Self::LastName(data) => data.to_selection(),
                Self::Phone(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::TeamId(data) => data.to_selection(),
                Self::Team(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: user :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: user :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: user :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: user :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { team } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub first_name : String , pub last_name : Option < String > , pub phone : Option < String > , pub email : String , pub team_id : String , $ (pub $ field : crate :: prisma :: user :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (first_name) , stringify ! (last_name) , stringify ! (phone) , stringify ! (email) , stringify ! (team_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: user :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: user :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: user :: first_name :: NAME , & self . first_name) ? ; state . serialize_field (crate :: prisma :: user :: last_name :: NAME , & self . last_name) ? ; state . serialize_field (crate :: prisma :: user :: phone :: NAME , & self . phone) ? ; state . serialize_field (crate :: prisma :: user :: email :: NAME , & self . email) ? ; state . serialize_field (crate :: prisma :: user :: team_id :: NAME , & self . team_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , first_name , last_name , phone , email , team_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: user :: $ field :: NAME) , + , crate :: prisma :: user :: id :: NAME , crate :: prisma :: user :: first_name :: NAME , crate :: prisma :: user :: last_name :: NAME , crate :: prisma :: user :: phone :: NAME , crate :: prisma :: user :: email :: NAME , crate :: prisma :: user :: team_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: user :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: user :: id :: NAME => Ok (Field :: id) , crate :: prisma :: user :: first_name :: NAME => Ok (Field :: first_name) , crate :: prisma :: user :: last_name :: NAME => Ok (Field :: last_name) , crate :: prisma :: user :: phone :: NAME => Ok (Field :: phone) , crate :: prisma :: user :: email :: NAME => Ok (Field :: email) , crate :: prisma :: user :: team_id :: NAME => Ok (Field :: team_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut first_name = None ; let mut last_name = None ; let mut phone = None ; let mut email = None ; let mut team_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: first_name => { if first_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: first_name :: NAME)) ; } first_name = Some (map . next_value () ?) ; } Field :: last_name => { if last_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: last_name :: NAME)) ; } last_name = Some (map . next_value () ?) ; } Field :: phone => { if phone . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: phone :: NAME)) ; } phone = Some (map . next_value () ?) ; } Field :: email => { if email . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: email :: NAME)) ; } email = Some (map . next_value () ?) ; } Field :: team_id => { if team_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: team_id :: NAME)) ; } team_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: id :: NAME)) ? ; let first_name = first_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: first_name :: NAME)) ? ; let last_name = last_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: last_name :: NAME)) ? ; let phone = phone . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: phone :: NAME)) ? ; let email = email . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: email :: NAME)) ? ; let team_id = team_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: team_id :: NAME)) ? ; Ok (Data { id , first_name , last_name , phone , email , team_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "first_name" , "last_name" , "phone" , "email" , "team_id" , "team"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: user :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; team : $ selection_mode : ident { $ ($ selections : tt) + }) => { team :: Data } ; (@ field_type ; team) => { crate :: prisma :: team :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "User" , available relations are "team")) } ; (@ field_module ; team : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: team :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; team $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: team :: Include :: $ selection_mode (crate :: prisma :: team :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; team $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: team :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; first_name) => { "first_name" } ; (@ field_serde_name ; last_name) => { "last_name" } ; (@ field_serde_name ; phone) => { "phone" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; team_id) => { "team_id" } ; (@ field_serde_name ; team) => { "team" } ; }
    pub use _include_user as include;
    pub enum IncludeParam {
        Id(id::Include),
        FirstName(first_name::Include),
        LastName(last_name::Include),
        Phone(phone::Include),
        Email(email::Include),
        TeamId(team_id::Include),
        Team(team::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::FirstName(data) => data.to_selection(),
                Self::LastName(data) => data.to_selection(),
                Self::Phone(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::TeamId(data) => data.to_selection(),
                Self::Team(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_user { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: user struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "first_name")] pub first_name : String , # [serde (rename = "last_name")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub last_name : Option < String > , # [serde (rename = "phone")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub phone : Option < String > , # [serde (rename = "email")] pub email : String , # [serde (rename = "team_id")] pub team_id : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_user as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "first_name")]
        pub first_name: String,
        #[serde(rename = "last_name")]
        pub last_name: Option<String>,
        #[serde(rename = "phone")]
        pub phone: Option<String>,
        #[serde(rename = "email")]
        pub email: String,
        #[serde(rename = "team_id")]
        pub team_id: String,
        #[serde(rename = "team")]
        pub team: Option<Box<super::team::Data>>,
    }
    impl Data {
        pub fn team(
            &self,
        ) -> Result<&super::team::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.team
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(team),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Team(super::team::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Team(args) => {
                    let mut selections =
                        <super::team::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(team::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetFirstName(String),
        SetLastName(Option<String>),
        SetPhone(Option<String>),
        SetEmail(String),
        SetTeamId(String),
        ConnectTeam(super::team::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetFirstName(value) => (
                    first_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetLastName(value) => (
                    last_name::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetPhone(value) => (
                    phone::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetEmail(value) => (
                    email::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetTeamId(value) => (
                    team_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectTeam(where_param) => (
                    team::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::team::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        FirstName(String),
        LastName(Option<String>),
        Phone(Option<String>),
        Email(String),
        TeamId(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::FirstName(value) => Self::SetFirstName(value),
                UncheckedSetParam::LastName(value) => Self::SetLastName(value),
                UncheckedSetParam::Phone(value) => Self::SetPhone(value),
                UncheckedSetParam::Email(value) => Self::SetEmail(value),
                UncheckedSetParam::TeamId(value) => Self::SetTeamId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        FirstName(::prisma_client_rust::Direction),
        LastName(::prisma_client_rust::Direction),
        Phone(::prisma_client_rust::Direction),
        Email(::prisma_client_rust::Direction),
        TeamId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::FirstName(direction) => (
                    first_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::LastName(direction) => (
                    last_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Phone(direction) => (
                    phone::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Email(direction) => (
                    email::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::TeamId(direction) => (
                    team_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        FirstName(_prisma::read_filters::StringFilter),
        LastName(_prisma::read_filters::StringNullableFilter),
        Phone(_prisma::read_filters::StringNullableFilter),
        Email(_prisma::read_filters::StringFilter),
        TeamId(_prisma::read_filters::StringFilter),
        TeamIs(Vec<super::team::WhereParam>),
        TeamIsNot(Vec<super::team::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::FirstName(value) => (first_name::NAME, value.into()),
                Self::LastName(value) => (last_name::NAME, value.into()),
                Self::Phone(value) => (phone::NAME, value.into()),
                Self::Email(value) => (email::NAME, value.into()),
                Self::TeamId(value) => (team_id::NAME, value.into()),
                Self::TeamIs(where_params) => (
                    team::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TeamIsNot(where_params) => (
                    team::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        EmailEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::EmailEquals(value) => {
                    Self::Email(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(first_name::NAME),
                ::prisma_client_rust::sel(last_name::NAME),
                ::prisma_client_rust::sel(phone::NAME),
                ::prisma_client_rust::sel(email::NAME),
                ::prisma_client_rust::sel(team_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            id: String,
            first_name: String,
            email: String,
            team: super::team::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                id::set(id),
                first_name::set(first_name),
                email::set(email),
                team::connect(team),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            id: String,
            first_name: String,
            email: String,
            team_id: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                id::set(id),
                first_name::set(first_name),
                email::set(email),
                team_id::set(team_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(id, first_name, email, team_id, mut _params)| {
                    _params.extend([
                        id::set(id),
                        first_name::set(first_name),
                        email::set(email),
                        team_id::set(team_id),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (id, first_name, email, team, mut _params): (
                String,
                String,
                String,
                super::team::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                id::set(id),
                first_name::set(first_name),
                email::set(email),
                team::connect(team),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod organization {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Organization";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod email {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "email";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetEmail(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Email(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Email(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Email,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Email(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Email(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod phone {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "phone";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPhone(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Phone(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Phone(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Phone(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Phone,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Phone(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Phone(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod locations {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "locations";
        pub struct Fetch(pub location::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<location::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: location::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: location::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Locations(v)
            }
        }
        pub fn fetch(params: Vec<location::WhereParam>) -> Fetch {
            Fetch(location::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<location::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectLocations(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<location::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<location::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectLocations(params)
        }
        pub fn set(params: Vec<location::UniqueWhereParam>) -> SetParam {
            SetParam::SetLocations(params)
        }
        pub fn some(value: Vec<location::WhereParam>) -> WhereParam {
            WhereParam::LocationsSome(value)
        }
        pub fn every(value: Vec<location::WhereParam>) -> WhereParam {
            WhereParam::LocationsEvery(value)
        }
        pub fn none(value: Vec<location::WhereParam>) -> WhereParam {
            WhereParam::LocationsNone(value)
        }
        pub enum Include {
            Select(location::ManyArgs, Vec<location::SelectParam>),
            Include(location::ManyArgs, Vec<location::IncludeParam>),
            Fetch(location::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Locations(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <location::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: location::ManyArgs,
                nested_selections: Vec<location::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: location::ManyArgs,
                nested_selections: Vec<location::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(location::ManyArgs, Vec<location::SelectParam>),
            Include(location::ManyArgs, Vec<location::IncludeParam>),
            Fetch(location::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Locations(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <location::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: location::ManyArgs,
                nested_selections: Vec<location::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: location::ManyArgs,
                nested_selections: Vec<location::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        id: String,
        name: String,
        email: String,
        phone: String,
        _params: Vec<SetParam>,
    ) -> (String, String, String, String, Vec<SetParam>) {
        (id, name, email, phone, _params)
    }
    pub fn create_unchecked(
        id: String,
        name: String,
        email: String,
        phone: String,
        _params: Vec<SetParam>,
    ) -> (String, String, String, String, Vec<SetParam>) {
        (id, name, email, phone, _params)
    }
    #[macro_export]
    macro_rules ! _select_organization { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: organization :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: organization :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: organization :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: organization :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: organization :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: organization :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , email , phone , locations } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: organization :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: organization :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: organization :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: organization :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: organization :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: organization :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "email" , "phone" , "locations"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: organization :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; email) => { String } ; (@ field_type ; phone) => { String } ; (@ field_type ; locations : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < locations :: Data > } ; (@ field_type ; locations) => { Vec < crate :: prisma :: location :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Organization" , available relations are "id, name, email, phone, locations")) } ; (@ field_module ; locations : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: location :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: organization :: SelectParam > :: into (crate :: prisma :: organization :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: organization :: SelectParam > :: into (crate :: prisma :: organization :: name :: Select) } ; (@ selection_field_to_selection_param ; email) => { Into :: < crate :: prisma :: organization :: SelectParam > :: into (crate :: prisma :: organization :: email :: Select) } ; (@ selection_field_to_selection_param ; phone) => { Into :: < crate :: prisma :: organization :: SelectParam > :: into (crate :: prisma :: organization :: phone :: Select) } ; (@ selection_field_to_selection_param ; locations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: organization :: SelectParam > :: into (crate :: prisma :: organization :: locations :: Select :: $ selection_mode (crate :: prisma :: location :: ManyArgs :: new (crate :: prisma :: location :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; locations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: organization :: SelectParam > :: into (crate :: prisma :: organization :: locations :: Select :: Fetch (crate :: prisma :: location :: ManyArgs :: new (crate :: prisma :: location :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: organization :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; phone) => { "phone" } ; (@ field_serde_name ; locations) => { "locations" } ; }
    pub use _select_organization as select;
    pub enum SelectParam {
        Id(id::Select),
        Name(name::Select),
        Email(email::Select),
        Phone(phone::Select),
        Locations(locations::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::Phone(data) => data.to_selection(),
                Self::Locations(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_organization { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: organization :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: organization :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: organization :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: organization :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: organization :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: organization :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: organization :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: organization :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { locations } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub name : String , pub email : String , pub phone : String , $ (pub $ field : crate :: prisma :: organization :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (email) , stringify ! (phone)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: organization :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: organization :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: organization :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: organization :: email :: NAME , & self . email) ? ; state . serialize_field (crate :: prisma :: organization :: phone :: NAME , & self . phone) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , email , phone } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: organization :: $ field :: NAME) , + , crate :: prisma :: organization :: id :: NAME , crate :: prisma :: organization :: name :: NAME , crate :: prisma :: organization :: email :: NAME , crate :: prisma :: organization :: phone :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: organization :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: organization :: id :: NAME => Ok (Field :: id) , crate :: prisma :: organization :: name :: NAME => Ok (Field :: name) , crate :: prisma :: organization :: email :: NAME => Ok (Field :: email) , crate :: prisma :: organization :: phone :: NAME => Ok (Field :: phone) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut email = None ; let mut phone = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: organization :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: organization :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: email => { if email . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: organization :: email :: NAME)) ; } email = Some (map . next_value () ?) ; } Field :: phone => { if phone . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: organization :: phone :: NAME)) ; } phone = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: organization :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: organization :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: organization :: id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: organization :: name :: NAME)) ? ; let email = email . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: organization :: email :: NAME)) ? ; let phone = phone . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: organization :: phone :: NAME)) ? ; Ok (Data { id , name , email , phone , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "email" , "phone" , "locations"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: organization :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; locations : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < locations :: Data > } ; (@ field_type ; locations) => { Vec < crate :: prisma :: location :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Organization" , available relations are "locations")) } ; (@ field_module ; locations : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: location :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; locations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: organization :: IncludeParam > :: into (crate :: prisma :: organization :: locations :: Include :: $ selection_mode (crate :: prisma :: location :: ManyArgs :: new (crate :: prisma :: location :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; locations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: organization :: IncludeParam > :: into (crate :: prisma :: organization :: locations :: Include :: Fetch (crate :: prisma :: location :: ManyArgs :: new (crate :: prisma :: location :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: organization :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; phone) => { "phone" } ; (@ field_serde_name ; locations) => { "locations" } ; }
    pub use _include_organization as include;
    pub enum IncludeParam {
        Id(id::Include),
        Name(name::Include),
        Email(email::Include),
        Phone(phone::Include),
        Locations(locations::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::Phone(data) => data.to_selection(),
                Self::Locations(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_organization { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: organization struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "name")] pub name : String , # [serde (rename = "email")] pub email : String , # [serde (rename = "phone")] pub phone : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_organization as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "email")]
        pub email: String,
        #[serde(rename = "phone")]
        pub phone: String,
        #[serde(rename = "locations")]
        pub locations: Option<Vec<super::location::Data>>,
    }
    impl Data {
        pub fn locations(
            &self,
        ) -> Result<&Vec<super::location::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.locations
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(locations),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Locations(super::location::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Locations(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        locations::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetName(String),
        SetEmail(String),
        SetPhone(String),
        ConnectLocations(Vec<super::location::UniqueWhereParam>),
        DisconnectLocations(Vec<super::location::UniqueWhereParam>),
        SetLocations(Vec<super::location::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetEmail(value) => (
                    email::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetPhone(value) => (
                    phone::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectLocations(where_params) => (
                    locations::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::location::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectLocations(where_params) => (
                    locations::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::location::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetLocations(where_params) => (
                    locations::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::location::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        Name(String),
        Email(String),
        Phone(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Name(value) => Self::SetName(value),
                UncheckedSetParam::Email(value) => Self::SetEmail(value),
                UncheckedSetParam::Phone(value) => Self::SetPhone(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        Email(::prisma_client_rust::Direction),
        Phone(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Email(direction) => (
                    email::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Phone(direction) => (
                    phone::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        Name(_prisma::read_filters::StringFilter),
        Email(_prisma::read_filters::StringFilter),
        Phone(_prisma::read_filters::StringFilter),
        LocationsSome(Vec<super::location::WhereParam>),
        LocationsEvery(Vec<super::location::WhereParam>),
        LocationsNone(Vec<super::location::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::Email(value) => (email::NAME, value.into()),
                Self::Phone(value) => (phone::NAME, value.into()),
                Self::LocationsSome(where_params) => (
                    locations::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::LocationsEvery(where_params) => (
                    locations::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::LocationsNone(where_params) => (
                    locations::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(email::NAME),
                ::prisma_client_rust::sel(phone::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            id: String,
            name: String,
            email: String,
            phone: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                id::set(id),
                name::set(name),
                email::set(email),
                phone::set(phone),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            id: String,
            name: String,
            email: String,
            phone: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                id::set(id),
                name::set(name),
                email::set(email),
                phone::set(phone),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(id, name, email, phone, mut _params)| {
                    _params.extend([
                        id::set(id),
                        name::set(name),
                        email::set(email),
                        phone::set(phone),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (id, name, email, phone, mut _params): (String, String, String, String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                id::set(id),
                name::set(name),
                email::set(email),
                phone::set(phone),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod user_role {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "UserRole";
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "user_id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUserId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UserId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            UserId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod organization_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "organization_id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetOrganizationId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::OrganizationId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::OrganizationId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::OrganizationId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            OrganizationId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::OrganizationId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::OrganizationId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod role {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "role";
        pub struct Set(pub self::Role);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRole(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Role(v)
            }
        }
        pub fn set<T: From<Set>>(value: self::Role) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Role(direction)
        }
        pub fn equals(value: self::Role) -> WhereParam {
            WhereParam::Role(_prisma::read_filters::RoleFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::RoleFilter, Role, {
            fn in_vec(_: Vec<super::super::Role>) -> InVec;
            fn not_in_vec(_: Vec<super::super::Role>) -> NotInVec;
            fn not(_: super::super::Role) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Role(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Role(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn user_id_organization_id<T: From<UniqueWhereParam>>(
        user_id: String,
        organization_id: String,
    ) -> T {
        UniqueWhereParam::UserIdOrganizationIdEquals(user_id, organization_id).into()
    }
    pub fn create(
        user_id: String,
        organization_id: String,
        role: super::Role,
        _params: Vec<SetParam>,
    ) -> (String, String, super::Role, Vec<SetParam>) {
        (user_id, organization_id, role, _params)
    }
    pub fn create_unchecked(
        user_id: String,
        organization_id: String,
        role: super::Role,
        _params: Vec<SetParam>,
    ) -> (String, String, super::Role, Vec<SetParam>) {
        (user_id, organization_id, role, _params)
    }
    #[macro_export]
    macro_rules ! _select_user_role { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: user_role :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user_role :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: user_role :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: user_role :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user_role :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: user_role :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { user_id , organization_id , role } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: user_role :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: user_role :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: user_role :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: user_role :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user_role :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user_role :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["user_id" , "organization_id" , "role"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: user_role :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; user_id) => { String } ; (@ field_type ; organization_id) => { String } ; (@ field_type ; role) => { crate :: prisma :: Role } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "UserRole" , available relations are "user_id, organization_id, role")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < crate :: prisma :: user_role :: SelectParam > :: into (crate :: prisma :: user_role :: user_id :: Select) } ; (@ selection_field_to_selection_param ; organization_id) => { Into :: < crate :: prisma :: user_role :: SelectParam > :: into (crate :: prisma :: user_role :: organization_id :: Select) } ; (@ selection_field_to_selection_param ; role) => { Into :: < crate :: prisma :: user_role :: SelectParam > :: into (crate :: prisma :: user_role :: role :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: user_role :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; organization_id) => { "organization_id" } ; (@ field_serde_name ; role) => { "role" } ; }
    pub use _select_user_role as select;
    pub enum SelectParam {
        UserId(user_id::Select),
        OrganizationId(organization_id::Select),
        Role(role::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::UserId(data) => data.to_selection(),
                Self::OrganizationId(data) => data.to_selection(),
                Self::Role(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_user_role { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: user_role :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user_role :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: user_role :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: user_role :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: user_role :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user_role :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: user_role :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: user_role :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub user_id : String , pub organization_id : String , pub role : crate :: prisma :: Role , $ (pub $ field : crate :: prisma :: user_role :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (user_id) , stringify ! (organization_id) , stringify ! (role)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: user_role :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: user_role :: user_id :: NAME , & self . user_id) ? ; state . serialize_field (crate :: prisma :: user_role :: organization_id :: NAME , & self . organization_id) ? ; state . serialize_field (crate :: prisma :: user_role :: role :: NAME , & self . role) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , user_id , organization_id , role } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: user_role :: $ field :: NAME) , + , crate :: prisma :: user_role :: user_id :: NAME , crate :: prisma :: user_role :: organization_id :: NAME , crate :: prisma :: user_role :: role :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: user_role :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: user_role :: user_id :: NAME => Ok (Field :: user_id) , crate :: prisma :: user_role :: organization_id :: NAME => Ok (Field :: organization_id) , crate :: prisma :: user_role :: role :: NAME => Ok (Field :: role) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut user_id = None ; let mut organization_id = None ; let mut role = None ; while let Some (key) = map . next_key () ? { match key { Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user_role :: user_id :: NAME)) ; } user_id = Some (map . next_value () ?) ; } Field :: organization_id => { if organization_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user_role :: organization_id :: NAME)) ; } organization_id = Some (map . next_value () ?) ; } Field :: role => { if role . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user_role :: role :: NAME)) ; } role = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user_role :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user_role :: $ field :: NAME)) ? ;) * let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user_role :: user_id :: NAME)) ? ; let organization_id = organization_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user_role :: organization_id :: NAME)) ? ; let role = role . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user_role :: role :: NAME)) ? ; Ok (Data { user_id , organization_id , role , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["user_id" , "organization_id" , "role"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: user_role :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "UserRole" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: user_role :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; organization_id) => { "organization_id" } ; (@ field_serde_name ; role) => { "role" } ; }
    pub use _include_user_role as include;
    pub enum IncludeParam {
        UserId(user_id::Include),
        OrganizationId(organization_id::Include),
        Role(role::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::UserId(data) => data.to_selection(),
                Self::OrganizationId(data) => data.to_selection(),
                Self::Role(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_user_role { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: user_role struct $ struct_name { # [serde (rename = "user_id")] pub user_id : String , # [serde (rename = "organization_id")] pub organization_id : String , # [serde (rename = "role")] pub role : crate :: prisma :: Role } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_user_role as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "user_id")]
        pub user_id: String,
        #[serde(rename = "organization_id")]
        pub organization_id: String,
        #[serde(rename = "role")]
        pub role: super::Role,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetUserId(String),
        SetOrganizationId(String),
        SetRole(super::Role),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetOrganizationId(value) => (
                    organization_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetRole(value) => (
                    role::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        UserId(String),
        OrganizationId(String),
        Role(super::Role),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::UserId(value) => Self::SetUserId(value),
                UncheckedSetParam::OrganizationId(value) => Self::SetOrganizationId(value),
                UncheckedSetParam::Role(value) => Self::SetRole(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        UserId(::prisma_client_rust::Direction),
        OrganizationId(::prisma_client_rust::Direction),
        Role(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::UserId(direction) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::OrganizationId(direction) => (
                    organization_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Role(direction) => (
                    role::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        UserIdOrganizationIdEquals(String, String),
        UserId(_prisma::read_filters::StringFilter),
        OrganizationId(_prisma::read_filters::StringFilter),
        Role(_prisma::read_filters::RoleFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::UserIdOrganizationIdEquals(user_id, organization_id) => (
                    "user_id_organization_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            user_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::String(user_id),
                        ),
                        (
                            organization_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::String(organization_id),
                        ),
                    ]),
                ),
                Self::UserId(value) => (user_id::NAME, value.into()),
                Self::OrganizationId(value) => (organization_id::NAME, value.into()),
                Self::Role(value) => (role::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        UserIdOrganizationIdEquals(String, String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::UserIdOrganizationIdEquals(user_id, organization_id) => {
                    Self::UserIdOrganizationIdEquals(user_id, organization_id)
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(user_id::NAME),
                ::prisma_client_rust::sel(organization_id::NAME),
                ::prisma_client_rust::sel(role::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            user_id: String,
            organization_id: String,
            role: super::Role,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                user_id::set(user_id),
                organization_id::set(organization_id),
                role::set(role),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            user_id: String,
            organization_id: String,
            role: super::Role,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                user_id::set(user_id),
                organization_id::set(organization_id),
                role::set(role),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, super::Role, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(user_id, organization_id, role, mut _params)| {
                    _params.extend([
                        user_id::set(user_id),
                        organization_id::set(organization_id),
                        role::set(role),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (user_id, organization_id, role, mut _params): (
                String,
                String,
                super::Role,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                user_id::set(user_id),
                organization_id::set(organization_id),
                role::set(role),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod location {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Location";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod email {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "email";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetEmail(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Email(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Email(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Email,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Email(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Email(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod phone {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "phone";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPhone(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Phone(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Phone(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Phone(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Phone,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Phone(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Phone(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod street {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "street";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetStreet(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Street(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Street(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Street(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Street,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Street(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Street(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod city {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "city";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCity(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::City(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::City(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::City(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, City, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::City(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::City(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod state {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "state";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetState(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::State(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::State(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::State(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            State,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::State(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::State(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod country {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "country";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCountry(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Country(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Country(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Country(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Country,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Country(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Country(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod postcode {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "postcode";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPostcode(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Postcode(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Postcode(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Postcode(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Postcode,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Postcode(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Postcode(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod teams {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "teams";
        pub struct Fetch(pub team::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<team::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: team::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: team::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Teams(v)
            }
        }
        pub fn fetch(params: Vec<team::WhereParam>) -> Fetch {
            Fetch(team::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<team::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectTeams(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<team::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<team::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectTeams(params)
        }
        pub fn set(params: Vec<team::UniqueWhereParam>) -> SetParam {
            SetParam::SetTeams(params)
        }
        pub fn some(value: Vec<team::WhereParam>) -> WhereParam {
            WhereParam::TeamsSome(value)
        }
        pub fn every(value: Vec<team::WhereParam>) -> WhereParam {
            WhereParam::TeamsEvery(value)
        }
        pub fn none(value: Vec<team::WhereParam>) -> WhereParam {
            WhereParam::TeamsNone(value)
        }
        pub enum Include {
            Select(team::ManyArgs, Vec<team::SelectParam>),
            Include(team::ManyArgs, Vec<team::IncludeParam>),
            Fetch(team::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Teams(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <team::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <team::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(args: team::ManyArgs, nested_selections: Vec<team::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: team::ManyArgs,
                nested_selections: Vec<team::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(team::ManyArgs, Vec<team::SelectParam>),
            Include(team::ManyArgs, Vec<team::IncludeParam>),
            Fetch(team::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Teams(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <team::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(args: team::ManyArgs, nested_selections: Vec<team::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: team::ManyArgs,
                nested_selections: Vec<team::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod organization_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "organization_id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetOrganizationId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::OrganizationId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::OrganizationId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::OrganizationId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            OrganizationId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::OrganizationId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::OrganizationId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod organization {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "organization";
        pub struct Fetch(pub organization::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<organization::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Organization(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(organization::UniqueArgs::new())
        }
        pub struct Connect(organization::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectOrganization(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: organization::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<organization::WhereParam>) -> WhereParam {
            WhereParam::OrganizationIs(value)
        }
        pub fn is_not(value: Vec<organization::WhereParam>) -> WhereParam {
            WhereParam::OrganizationIsNot(value)
        }
        pub enum Include {
            Select(Vec<organization::SelectParam>),
            Include(Vec<organization::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Organization(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < organization :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <organization::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        )
                    }
                };
                ::prisma_client_rust::Selection::new("organization", None, [], selections)
            }
            pub fn select(nested_selections: Vec<organization::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<organization::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<organization::SelectParam>),
            Include(Vec<organization::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Organization(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <organization::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        )
                    }
                };
                ::prisma_client_rust::Selection::new("organization", None, [], selections)
            }
            pub fn select(nested_selections: Vec<organization::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<organization::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        id: String,
        name: String,
        email: String,
        phone: String,
        street: String,
        city: String,
        state: String,
        country: String,
        postcode: String,
        organization: super::organization::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        String,
        String,
        String,
        String,
        String,
        String,
        super::organization::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (
            id,
            name,
            email,
            phone,
            street,
            city,
            state,
            country,
            postcode,
            organization,
            _params,
        )
    }
    pub fn create_unchecked(
        id: String,
        name: String,
        email: String,
        phone: String,
        street: String,
        city: String,
        state: String,
        country: String,
        postcode: String,
        organization_id: String,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        String,
        String,
        String,
        String,
        String,
        String,
        String,
        Vec<SetParam>,
    ) {
        (
            id,
            name,
            email,
            phone,
            street,
            city,
            state,
            country,
            postcode,
            organization_id,
            _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_location { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: location :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: location :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: location :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: location :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , email , phone , street , city , state , country , postcode , teams , organization_id , organization } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: location :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: location :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: location :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: location :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "email" , "phone" , "street" , "city" , "state" , "country" , "postcode" , "teams" , "organization_id" , "organization"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: location :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; email) => { String } ; (@ field_type ; phone) => { String } ; (@ field_type ; street) => { String } ; (@ field_type ; city) => { String } ; (@ field_type ; state) => { String } ; (@ field_type ; country) => { String } ; (@ field_type ; postcode) => { String } ; (@ field_type ; teams : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < teams :: Data > } ; (@ field_type ; teams) => { Vec < crate :: prisma :: team :: Data > } ; (@ field_type ; organization_id) => { String } ; (@ field_type ; organization : $ selection_mode : ident { $ ($ selections : tt) + }) => { organization :: Data } ; (@ field_type ; organization) => { crate :: prisma :: organization :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Location" , available relations are "id, name, email, phone, street, city, state, country, postcode, teams, organization_id, organization")) } ; (@ field_module ; teams : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: team :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; organization : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: organization :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: name :: Select) } ; (@ selection_field_to_selection_param ; email) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: email :: Select) } ; (@ selection_field_to_selection_param ; phone) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: phone :: Select) } ; (@ selection_field_to_selection_param ; street) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: street :: Select) } ; (@ selection_field_to_selection_param ; city) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: city :: Select) } ; (@ selection_field_to_selection_param ; state) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: state :: Select) } ; (@ selection_field_to_selection_param ; country) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: country :: Select) } ; (@ selection_field_to_selection_param ; postcode) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: postcode :: Select) } ; (@ selection_field_to_selection_param ; teams $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: teams :: Select :: $ selection_mode (crate :: prisma :: team :: ManyArgs :: new (crate :: prisma :: team :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: team :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; teams $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: teams :: Select :: Fetch (crate :: prisma :: team :: ManyArgs :: new (crate :: prisma :: team :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; organization_id) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: organization_id :: Select) } ; (@ selection_field_to_selection_param ; organization $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: organization :: Select :: $ selection_mode (crate :: prisma :: organization :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; organization $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: organization :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: location :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; phone) => { "phone" } ; (@ field_serde_name ; street) => { "street" } ; (@ field_serde_name ; city) => { "city" } ; (@ field_serde_name ; state) => { "state" } ; (@ field_serde_name ; country) => { "country" } ; (@ field_serde_name ; postcode) => { "postcode" } ; (@ field_serde_name ; teams) => { "teams" } ; (@ field_serde_name ; organization_id) => { "organization_id" } ; (@ field_serde_name ; organization) => { "organization" } ; }
    pub use _select_location as select;
    pub enum SelectParam {
        Id(id::Select),
        Name(name::Select),
        Email(email::Select),
        Phone(phone::Select),
        Street(street::Select),
        City(city::Select),
        State(state::Select),
        Country(country::Select),
        Postcode(postcode::Select),
        Teams(teams::Select),
        OrganizationId(organization_id::Select),
        Organization(organization::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::Phone(data) => data.to_selection(),
                Self::Street(data) => data.to_selection(),
                Self::City(data) => data.to_selection(),
                Self::State(data) => data.to_selection(),
                Self::Country(data) => data.to_selection(),
                Self::Postcode(data) => data.to_selection(),
                Self::Teams(data) => data.to_selection(),
                Self::OrganizationId(data) => data.to_selection(),
                Self::Organization(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_location { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: location :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: location :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: location :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: location :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { teams , organization } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub name : String , pub email : String , pub phone : String , pub street : String , pub city : String , pub state : String , pub country : String , pub postcode : String , pub organization_id : String , $ (pub $ field : crate :: prisma :: location :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (email) , stringify ! (phone) , stringify ! (street) , stringify ! (city) , stringify ! (state) , stringify ! (country) , stringify ! (postcode) , stringify ! (organization_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: location :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: location :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: location :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: location :: email :: NAME , & self . email) ? ; state . serialize_field (crate :: prisma :: location :: phone :: NAME , & self . phone) ? ; state . serialize_field (crate :: prisma :: location :: street :: NAME , & self . street) ? ; state . serialize_field (crate :: prisma :: location :: city :: NAME , & self . city) ? ; state . serialize_field (crate :: prisma :: location :: state :: NAME , & self . state) ? ; state . serialize_field (crate :: prisma :: location :: country :: NAME , & self . country) ? ; state . serialize_field (crate :: prisma :: location :: postcode :: NAME , & self . postcode) ? ; state . serialize_field (crate :: prisma :: location :: organization_id :: NAME , & self . organization_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , email , phone , street , city , state , country , postcode , organization_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: location :: $ field :: NAME) , + , crate :: prisma :: location :: id :: NAME , crate :: prisma :: location :: name :: NAME , crate :: prisma :: location :: email :: NAME , crate :: prisma :: location :: phone :: NAME , crate :: prisma :: location :: street :: NAME , crate :: prisma :: location :: city :: NAME , crate :: prisma :: location :: state :: NAME , crate :: prisma :: location :: country :: NAME , crate :: prisma :: location :: postcode :: NAME , crate :: prisma :: location :: organization_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: location :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: location :: id :: NAME => Ok (Field :: id) , crate :: prisma :: location :: name :: NAME => Ok (Field :: name) , crate :: prisma :: location :: email :: NAME => Ok (Field :: email) , crate :: prisma :: location :: phone :: NAME => Ok (Field :: phone) , crate :: prisma :: location :: street :: NAME => Ok (Field :: street) , crate :: prisma :: location :: city :: NAME => Ok (Field :: city) , crate :: prisma :: location :: state :: NAME => Ok (Field :: state) , crate :: prisma :: location :: country :: NAME => Ok (Field :: country) , crate :: prisma :: location :: postcode :: NAME => Ok (Field :: postcode) , crate :: prisma :: location :: organization_id :: NAME => Ok (Field :: organization_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut email = None ; let mut phone = None ; let mut street = None ; let mut city = None ; let mut state = None ; let mut country = None ; let mut postcode = None ; let mut organization_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: email => { if email . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: email :: NAME)) ; } email = Some (map . next_value () ?) ; } Field :: phone => { if phone . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: phone :: NAME)) ; } phone = Some (map . next_value () ?) ; } Field :: street => { if street . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: street :: NAME)) ; } street = Some (map . next_value () ?) ; } Field :: city => { if city . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: city :: NAME)) ; } city = Some (map . next_value () ?) ; } Field :: state => { if state . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: state :: NAME)) ; } state = Some (map . next_value () ?) ; } Field :: country => { if country . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: country :: NAME)) ; } country = Some (map . next_value () ?) ; } Field :: postcode => { if postcode . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: postcode :: NAME)) ; } postcode = Some (map . next_value () ?) ; } Field :: organization_id => { if organization_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: organization_id :: NAME)) ; } organization_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: name :: NAME)) ? ; let email = email . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: email :: NAME)) ? ; let phone = phone . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: phone :: NAME)) ? ; let street = street . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: street :: NAME)) ? ; let city = city . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: city :: NAME)) ? ; let state = state . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: state :: NAME)) ? ; let country = country . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: country :: NAME)) ? ; let postcode = postcode . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: postcode :: NAME)) ? ; let organization_id = organization_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: organization_id :: NAME)) ? ; Ok (Data { id , name , email , phone , street , city , state , country , postcode , organization_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "email" , "phone" , "street" , "city" , "state" , "country" , "postcode" , "teams" , "organization_id" , "organization"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: location :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; teams : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < teams :: Data > } ; (@ field_type ; teams) => { Vec < crate :: prisma :: team :: Data > } ; (@ field_type ; organization : $ selection_mode : ident { $ ($ selections : tt) + }) => { organization :: Data } ; (@ field_type ; organization) => { crate :: prisma :: organization :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Location" , available relations are "teams, organization")) } ; (@ field_module ; teams : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: team :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; organization : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: organization :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; teams $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: location :: IncludeParam > :: into (crate :: prisma :: location :: teams :: Include :: $ selection_mode (crate :: prisma :: team :: ManyArgs :: new (crate :: prisma :: team :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: team :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; teams $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: location :: IncludeParam > :: into (crate :: prisma :: location :: teams :: Include :: Fetch (crate :: prisma :: team :: ManyArgs :: new (crate :: prisma :: team :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; organization $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: location :: IncludeParam > :: into (crate :: prisma :: location :: organization :: Include :: $ selection_mode (crate :: prisma :: organization :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; organization $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: location :: IncludeParam > :: into (crate :: prisma :: location :: organization :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: location :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; phone) => { "phone" } ; (@ field_serde_name ; street) => { "street" } ; (@ field_serde_name ; city) => { "city" } ; (@ field_serde_name ; state) => { "state" } ; (@ field_serde_name ; country) => { "country" } ; (@ field_serde_name ; postcode) => { "postcode" } ; (@ field_serde_name ; teams) => { "teams" } ; (@ field_serde_name ; organization_id) => { "organization_id" } ; (@ field_serde_name ; organization) => { "organization" } ; }
    pub use _include_location as include;
    pub enum IncludeParam {
        Id(id::Include),
        Name(name::Include),
        Email(email::Include),
        Phone(phone::Include),
        Street(street::Include),
        City(city::Include),
        State(state::Include),
        Country(country::Include),
        Postcode(postcode::Include),
        Teams(teams::Include),
        OrganizationId(organization_id::Include),
        Organization(organization::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::Phone(data) => data.to_selection(),
                Self::Street(data) => data.to_selection(),
                Self::City(data) => data.to_selection(),
                Self::State(data) => data.to_selection(),
                Self::Country(data) => data.to_selection(),
                Self::Postcode(data) => data.to_selection(),
                Self::Teams(data) => data.to_selection(),
                Self::OrganizationId(data) => data.to_selection(),
                Self::Organization(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_location { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: location struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "name")] pub name : String , # [serde (rename = "email")] pub email : String , # [serde (rename = "phone")] pub phone : String , # [serde (rename = "street")] pub street : String , # [serde (rename = "city")] pub city : String , # [serde (rename = "state")] pub state : String , # [serde (rename = "country")] pub country : String , # [serde (rename = "postcode")] pub postcode : String , # [serde (rename = "organization_id")] pub organization_id : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_location as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "email")]
        pub email: String,
        #[serde(rename = "phone")]
        pub phone: String,
        #[serde(rename = "street")]
        pub street: String,
        #[serde(rename = "city")]
        pub city: String,
        #[serde(rename = "state")]
        pub state: String,
        #[serde(rename = "country")]
        pub country: String,
        #[serde(rename = "postcode")]
        pub postcode: String,
        #[serde(rename = "teams")]
        pub teams: Option<Vec<super::team::Data>>,
        #[serde(rename = "organization_id")]
        pub organization_id: String,
        #[serde(rename = "organization")]
        pub organization: Option<Box<super::organization::Data>>,
    }
    impl Data {
        pub fn teams(
            &self,
        ) -> Result<&Vec<super::team::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.teams
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(teams),
                ))
        }
        pub fn organization(
            &self,
        ) -> Result<&super::organization::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.organization
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(organization),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Teams(super::team::ManyArgs),
        Organization(super::organization::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Teams(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(
                        <super::team::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    );
                    ::prisma_client_rust::Selection::new(
                        teams::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Organization(args) => {
                    let mut selections = < super :: organization :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(organization::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetName(String),
        SetEmail(String),
        SetPhone(String),
        SetStreet(String),
        SetCity(String),
        SetState(String),
        SetCountry(String),
        SetPostcode(String),
        ConnectTeams(Vec<super::team::UniqueWhereParam>),
        DisconnectTeams(Vec<super::team::UniqueWhereParam>),
        SetTeams(Vec<super::team::UniqueWhereParam>),
        SetOrganizationId(String),
        ConnectOrganization(super::organization::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetEmail(value) => (
                    email::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetPhone(value) => (
                    phone::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetStreet(value) => (
                    street::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetCity(value) => (
                    city::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetState(value) => (
                    state::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetCountry(value) => (
                    country::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetPostcode(value) => (
                    postcode::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectTeams(where_params) => (
                    teams::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::team::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectTeams(where_params) => (
                    teams::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::team::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetTeams(where_params) => (
                    teams::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::team::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetOrganizationId(value) => (
                    organization_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectOrganization(where_param) => (
                    organization::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::organization::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        Name(String),
        Email(String),
        Phone(String),
        Street(String),
        City(String),
        State(String),
        Country(String),
        Postcode(String),
        OrganizationId(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Name(value) => Self::SetName(value),
                UncheckedSetParam::Email(value) => Self::SetEmail(value),
                UncheckedSetParam::Phone(value) => Self::SetPhone(value),
                UncheckedSetParam::Street(value) => Self::SetStreet(value),
                UncheckedSetParam::City(value) => Self::SetCity(value),
                UncheckedSetParam::State(value) => Self::SetState(value),
                UncheckedSetParam::Country(value) => Self::SetCountry(value),
                UncheckedSetParam::Postcode(value) => Self::SetPostcode(value),
                UncheckedSetParam::OrganizationId(value) => Self::SetOrganizationId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        Email(::prisma_client_rust::Direction),
        Phone(::prisma_client_rust::Direction),
        Street(::prisma_client_rust::Direction),
        City(::prisma_client_rust::Direction),
        State(::prisma_client_rust::Direction),
        Country(::prisma_client_rust::Direction),
        Postcode(::prisma_client_rust::Direction),
        OrganizationId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Email(direction) => (
                    email::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Phone(direction) => (
                    phone::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Street(direction) => (
                    street::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::City(direction) => (
                    city::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::State(direction) => (
                    state::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Country(direction) => (
                    country::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Postcode(direction) => (
                    postcode::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::OrganizationId(direction) => (
                    organization_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        Name(_prisma::read_filters::StringFilter),
        Email(_prisma::read_filters::StringFilter),
        Phone(_prisma::read_filters::StringFilter),
        Street(_prisma::read_filters::StringFilter),
        City(_prisma::read_filters::StringFilter),
        State(_prisma::read_filters::StringFilter),
        Country(_prisma::read_filters::StringFilter),
        Postcode(_prisma::read_filters::StringFilter),
        TeamsSome(Vec<super::team::WhereParam>),
        TeamsEvery(Vec<super::team::WhereParam>),
        TeamsNone(Vec<super::team::WhereParam>),
        OrganizationId(_prisma::read_filters::StringFilter),
        OrganizationIs(Vec<super::organization::WhereParam>),
        OrganizationIsNot(Vec<super::organization::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::Email(value) => (email::NAME, value.into()),
                Self::Phone(value) => (phone::NAME, value.into()),
                Self::Street(value) => (street::NAME, value.into()),
                Self::City(value) => (city::NAME, value.into()),
                Self::State(value) => (state::NAME, value.into()),
                Self::Country(value) => (country::NAME, value.into()),
                Self::Postcode(value) => (postcode::NAME, value.into()),
                Self::TeamsSome(where_params) => (
                    teams::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TeamsEvery(where_params) => (
                    teams::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TeamsNone(where_params) => (
                    teams::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::OrganizationId(value) => (organization_id::NAME, value.into()),
                Self::OrganizationIs(where_params) => (
                    organization::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::OrganizationIsNot(where_params) => (
                    organization::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(email::NAME),
                ::prisma_client_rust::sel(phone::NAME),
                ::prisma_client_rust::sel(street::NAME),
                ::prisma_client_rust::sel(city::NAME),
                ::prisma_client_rust::sel(state::NAME),
                ::prisma_client_rust::sel(country::NAME),
                ::prisma_client_rust::sel(postcode::NAME),
                ::prisma_client_rust::sel(organization_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            id: String,
            name: String,
            email: String,
            phone: String,
            street: String,
            city: String,
            state: String,
            country: String,
            postcode: String,
            organization: super::organization::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                id::set(id),
                name::set(name),
                email::set(email),
                phone::set(phone),
                street::set(street),
                city::set(city),
                state::set(state),
                country::set(country),
                postcode::set(postcode),
                organization::connect(organization),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            id: String,
            name: String,
            email: String,
            phone: String,
            street: String,
            city: String,
            state: String,
            country: String,
            postcode: String,
            organization_id: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                id::set(id),
                name::set(name),
                email::set(email),
                phone::set(phone),
                street::set(street),
                city::set(city),
                state::set(state),
                country::set(country),
                postcode::set(postcode),
                organization_id::set(organization_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(
                String,
                String,
                String,
                String,
                String,
                String,
                String,
                String,
                String,
                String,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(
                        id,
                        name,
                        email,
                        phone,
                        street,
                        city,
                        state,
                        country,
                        postcode,
                        organization_id,
                        mut _params,
                    )| {
                        _params.extend([
                            id::set(id),
                            name::set(name),
                            email::set(email),
                            phone::set(phone),
                            street::set(street),
                            city::set(city),
                            state::set(state),
                            country::set(country),
                            postcode::set(postcode),
                            organization_id::set(organization_id),
                        ]);
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (
                id,
                name,
                email,
                phone,
                street,
                city,
                state,
                country,
                postcode,
                organization,
                mut _params,
            ): (
                String,
                String,
                String,
                String,
                String,
                String,
                String,
                String,
                String,
                super::organization::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                id::set(id),
                name::set(name),
                email::set(email),
                phone::set(phone),
                street::set(street),
                city::set(city),
                state::set(state),
                country::set(country),
                postcode::set(postcode),
                organization::connect(organization),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod team {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Team";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod location_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "location_id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetLocationId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::LocationId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::LocationId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::LocationId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            LocationId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::LocationId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::LocationId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod members {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "members";
        pub struct Fetch(pub user::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: user::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: user::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Members(v)
            }
        }
        pub fn fetch(params: Vec<user::WhereParam>) -> Fetch {
            Fetch(user::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<user::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectMembers(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<user::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<user::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectMembers(params)
        }
        pub fn set(params: Vec<user::UniqueWhereParam>) -> SetParam {
            SetParam::SetMembers(params)
        }
        pub fn some(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::MembersSome(value)
        }
        pub fn every(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::MembersEvery(value)
        }
        pub fn none(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::MembersNone(value)
        }
        pub enum Include {
            Select(user::ManyArgs, Vec<user::SelectParam>),
            Include(user::ManyArgs, Vec<user::IncludeParam>),
            Fetch(user::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Members(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(args: user::ManyArgs, nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: user::ManyArgs,
                nested_selections: Vec<user::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(user::ManyArgs, Vec<user::SelectParam>),
            Include(user::ManyArgs, Vec<user::IncludeParam>),
            Fetch(user::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Members(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(args: user::ManyArgs, nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: user::ManyArgs,
                nested_selections: Vec<user::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod schedules {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "schedules";
        pub struct Fetch(pub schedule::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<schedule::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: schedule::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: schedule::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Schedules(v)
            }
        }
        pub fn fetch(params: Vec<schedule::WhereParam>) -> Fetch {
            Fetch(schedule::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<schedule::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectSchedules(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<schedule::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<schedule::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectSchedules(params)
        }
        pub fn set(params: Vec<schedule::UniqueWhereParam>) -> SetParam {
            SetParam::SetSchedules(params)
        }
        pub fn some(value: Vec<schedule::WhereParam>) -> WhereParam {
            WhereParam::SchedulesSome(value)
        }
        pub fn every(value: Vec<schedule::WhereParam>) -> WhereParam {
            WhereParam::SchedulesEvery(value)
        }
        pub fn none(value: Vec<schedule::WhereParam>) -> WhereParam {
            WhereParam::SchedulesNone(value)
        }
        pub enum Include {
            Select(schedule::ManyArgs, Vec<schedule::SelectParam>),
            Include(schedule::ManyArgs, Vec<schedule::IncludeParam>),
            Fetch(schedule::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Schedules(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < schedule :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <schedule::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: schedule::ManyArgs,
                nested_selections: Vec<schedule::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: schedule::ManyArgs,
                nested_selections: Vec<schedule::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(schedule::ManyArgs, Vec<schedule::SelectParam>),
            Include(schedule::ManyArgs, Vec<schedule::IncludeParam>),
            Fetch(schedule::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Schedules(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <schedule::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: schedule::ManyArgs,
                nested_selections: Vec<schedule::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: schedule::ManyArgs,
                nested_selections: Vec<schedule::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod location {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "location";
        pub struct Fetch(pub location::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<location::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Location(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(location::UniqueArgs::new())
        }
        pub struct Connect(location::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectLocation(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: location::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<location::WhereParam>) -> WhereParam {
            WhereParam::LocationIs(value)
        }
        pub fn is_not(value: Vec<location::WhereParam>) -> WhereParam {
            WhereParam::LocationIsNot(value)
        }
        pub enum Include {
            Select(Vec<location::SelectParam>),
            Include(Vec<location::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Location(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <location::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("location", None, [], selections)
            }
            pub fn select(nested_selections: Vec<location::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<location::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<location::SelectParam>),
            Include(Vec<location::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Location(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <location::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("location", None, [], selections)
            }
            pub fn select(nested_selections: Vec<location::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<location::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        id: String,
        name: String,
        location: super::location::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        super::location::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (id, name, location, _params)
    }
    pub fn create_unchecked(
        id: String,
        location_id: String,
        name: String,
        _params: Vec<SetParam>,
    ) -> (String, String, String, Vec<SetParam>) {
        (id, location_id, name, _params)
    }
    #[macro_export]
    macro_rules ! _select_team { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: team :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: team :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: team :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: team :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: team :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: team :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , location_id , name , members , schedules , location } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: team :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: team :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: team :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: team :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: team :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: team :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "location_id" , "name" , "members" , "schedules" , "location"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: team :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; location_id) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; members : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < members :: Data > } ; (@ field_type ; members) => { Vec < crate :: prisma :: user :: Data > } ; (@ field_type ; schedules : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < schedules :: Data > } ; (@ field_type ; schedules) => { Vec < crate :: prisma :: schedule :: Data > } ; (@ field_type ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { location :: Data } ; (@ field_type ; location) => { crate :: prisma :: location :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Team" , available relations are "id, location_id, name, members, schedules, location")) } ; (@ field_module ; members : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; schedules : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: schedule :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: location :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: team :: SelectParam > :: into (crate :: prisma :: team :: id :: Select) } ; (@ selection_field_to_selection_param ; location_id) => { Into :: < crate :: prisma :: team :: SelectParam > :: into (crate :: prisma :: team :: location_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: team :: SelectParam > :: into (crate :: prisma :: team :: name :: Select) } ; (@ selection_field_to_selection_param ; members $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: team :: SelectParam > :: into (crate :: prisma :: team :: members :: Select :: $ selection_mode (crate :: prisma :: user :: ManyArgs :: new (crate :: prisma :: user :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; members $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: team :: SelectParam > :: into (crate :: prisma :: team :: members :: Select :: Fetch (crate :: prisma :: user :: ManyArgs :: new (crate :: prisma :: user :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; schedules $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: team :: SelectParam > :: into (crate :: prisma :: team :: schedules :: Select :: $ selection_mode (crate :: prisma :: schedule :: ManyArgs :: new (crate :: prisma :: schedule :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: schedule :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; schedules $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: team :: SelectParam > :: into (crate :: prisma :: team :: schedules :: Select :: Fetch (crate :: prisma :: schedule :: ManyArgs :: new (crate :: prisma :: schedule :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: team :: SelectParam > :: into (crate :: prisma :: team :: location :: Select :: $ selection_mode (crate :: prisma :: location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: team :: SelectParam > :: into (crate :: prisma :: team :: location :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: team :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; location_id) => { "location_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; members) => { "members" } ; (@ field_serde_name ; schedules) => { "schedules" } ; (@ field_serde_name ; location) => { "location" } ; }
    pub use _select_team as select;
    pub enum SelectParam {
        Id(id::Select),
        LocationId(location_id::Select),
        Name(name::Select),
        Members(members::Select),
        Schedules(schedules::Select),
        Location(location::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::LocationId(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Members(data) => data.to_selection(),
                Self::Schedules(data) => data.to_selection(),
                Self::Location(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_team { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: team :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: team :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: team :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: team :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: team :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: team :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: team :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: team :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { members , schedules , location } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub location_id : String , pub name : String , $ (pub $ field : crate :: prisma :: team :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (location_id) , stringify ! (name)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: team :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: team :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: team :: location_id :: NAME , & self . location_id) ? ; state . serialize_field (crate :: prisma :: team :: name :: NAME , & self . name) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , location_id , name } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: team :: $ field :: NAME) , + , crate :: prisma :: team :: id :: NAME , crate :: prisma :: team :: location_id :: NAME , crate :: prisma :: team :: name :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: team :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: team :: id :: NAME => Ok (Field :: id) , crate :: prisma :: team :: location_id :: NAME => Ok (Field :: location_id) , crate :: prisma :: team :: name :: NAME => Ok (Field :: name) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut location_id = None ; let mut name = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: team :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: location_id => { if location_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: team :: location_id :: NAME)) ; } location_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: team :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: team :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: team :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: team :: id :: NAME)) ? ; let location_id = location_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: team :: location_id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: team :: name :: NAME)) ? ; Ok (Data { id , location_id , name , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "location_id" , "name" , "members" , "schedules" , "location"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: team :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; members : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < members :: Data > } ; (@ field_type ; members) => { Vec < crate :: prisma :: user :: Data > } ; (@ field_type ; schedules : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < schedules :: Data > } ; (@ field_type ; schedules) => { Vec < crate :: prisma :: schedule :: Data > } ; (@ field_type ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { location :: Data } ; (@ field_type ; location) => { crate :: prisma :: location :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Team" , available relations are "members, schedules, location")) } ; (@ field_module ; members : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; schedules : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: schedule :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: location :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; members $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: team :: IncludeParam > :: into (crate :: prisma :: team :: members :: Include :: $ selection_mode (crate :: prisma :: user :: ManyArgs :: new (crate :: prisma :: user :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; members $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: team :: IncludeParam > :: into (crate :: prisma :: team :: members :: Include :: Fetch (crate :: prisma :: user :: ManyArgs :: new (crate :: prisma :: user :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; schedules $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: team :: IncludeParam > :: into (crate :: prisma :: team :: schedules :: Include :: $ selection_mode (crate :: prisma :: schedule :: ManyArgs :: new (crate :: prisma :: schedule :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: schedule :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; schedules $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: team :: IncludeParam > :: into (crate :: prisma :: team :: schedules :: Include :: Fetch (crate :: prisma :: schedule :: ManyArgs :: new (crate :: prisma :: schedule :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: team :: IncludeParam > :: into (crate :: prisma :: team :: location :: Include :: $ selection_mode (crate :: prisma :: location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: team :: IncludeParam > :: into (crate :: prisma :: team :: location :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: team :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; location_id) => { "location_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; members) => { "members" } ; (@ field_serde_name ; schedules) => { "schedules" } ; (@ field_serde_name ; location) => { "location" } ; }
    pub use _include_team as include;
    pub enum IncludeParam {
        Id(id::Include),
        LocationId(location_id::Include),
        Name(name::Include),
        Members(members::Include),
        Schedules(schedules::Include),
        Location(location::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::LocationId(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Members(data) => data.to_selection(),
                Self::Schedules(data) => data.to_selection(),
                Self::Location(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_team { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: team struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "location_id")] pub location_id : String , # [serde (rename = "name")] pub name : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_team as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "location_id")]
        pub location_id: String,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "members")]
        pub members: Option<Vec<super::user::Data>>,
        #[serde(rename = "schedules")]
        pub schedules: Option<Vec<super::schedule::Data>>,
        #[serde(rename = "location")]
        pub location: Option<Box<super::location::Data>>,
    }
    impl Data {
        pub fn members(
            &self,
        ) -> Result<&Vec<super::user::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.members
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(members),
                ))
        }
        pub fn schedules(
            &self,
        ) -> Result<&Vec<super::schedule::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.schedules
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(schedules),
                ))
        }
        pub fn location(
            &self,
        ) -> Result<&super::location::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.location
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(location),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Members(super::user::ManyArgs),
        Schedules(super::schedule::ManyArgs),
        Location(super::location::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Members(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(
                        <super::user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    );
                    ::prisma_client_rust::Selection::new(
                        members::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Schedules(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: schedule :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        schedules::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Location(args) => {
                    let mut selections = < super :: location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(location::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetLocationId(String),
        SetName(String),
        ConnectMembers(Vec<super::user::UniqueWhereParam>),
        DisconnectMembers(Vec<super::user::UniqueWhereParam>),
        SetMembers(Vec<super::user::UniqueWhereParam>),
        ConnectSchedules(Vec<super::schedule::UniqueWhereParam>),
        DisconnectSchedules(Vec<super::schedule::UniqueWhereParam>),
        SetSchedules(Vec<super::schedule::UniqueWhereParam>),
        ConnectLocation(super::location::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetLocationId(value) => (
                    location_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectMembers(where_params) => (
                    members::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectMembers(where_params) => (
                    members::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetMembers(where_params) => (
                    members::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectSchedules(where_params) => (
                    schedules::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::schedule::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectSchedules(where_params) => (
                    schedules::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::schedule::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetSchedules(where_params) => (
                    schedules::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::schedule::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectLocation(where_param) => (
                    location::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::location::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        LocationId(String),
        Name(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::LocationId(value) => Self::SetLocationId(value),
                UncheckedSetParam::Name(value) => Self::SetName(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        LocationId(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::LocationId(direction) => (
                    location_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        LocationId(_prisma::read_filters::StringFilter),
        Name(_prisma::read_filters::StringFilter),
        MembersSome(Vec<super::user::WhereParam>),
        MembersEvery(Vec<super::user::WhereParam>),
        MembersNone(Vec<super::user::WhereParam>),
        SchedulesSome(Vec<super::schedule::WhereParam>),
        SchedulesEvery(Vec<super::schedule::WhereParam>),
        SchedulesNone(Vec<super::schedule::WhereParam>),
        LocationIs(Vec<super::location::WhereParam>),
        LocationIsNot(Vec<super::location::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::LocationId(value) => (location_id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::MembersSome(where_params) => (
                    members::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MembersEvery(where_params) => (
                    members::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MembersNone(where_params) => (
                    members::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SchedulesSome(where_params) => (
                    schedules::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SchedulesEvery(where_params) => (
                    schedules::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SchedulesNone(where_params) => (
                    schedules::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::LocationIs(where_params) => (
                    location::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::LocationIsNot(where_params) => (
                    location::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(location_id::NAME),
                ::prisma_client_rust::sel(name::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            id: String,
            name: String,
            location: super::location::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([id::set(id), name::set(name), location::connect(location)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            id: String,
            location_id: String,
            name: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([id::set(id), location_id::set(location_id), name::set(name)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(id, location_id, name, mut _params)| {
                    _params.extend([id::set(id), location_id::set(location_id), name::set(name)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (id, name, location, mut _params): (
                String,
                String,
                super::location::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([id::set(id), name::set(name), location::connect(location)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod schedule {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Schedule";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod team_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "team_id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTeamId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TeamId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::TeamId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::TeamId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            TeamId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TeamId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TeamId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod start_date {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "start_date";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetStartDate(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::StartDate(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::StartDate(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::StartDate(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            StartDate,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::StartDate(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::StartDate(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod end_date {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "end_date";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetEndDate(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::EndDate(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::EndDate(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::EndDate(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            EndDate,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::EndDate(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::EndDate(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod shifts {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "shifts";
        pub struct Fetch(pub shift::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<shift::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: shift::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: shift::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Shifts(v)
            }
        }
        pub fn fetch(params: Vec<shift::WhereParam>) -> Fetch {
            Fetch(shift::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<shift::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectShifts(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<shift::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<shift::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectShifts(params)
        }
        pub fn set(params: Vec<shift::UniqueWhereParam>) -> SetParam {
            SetParam::SetShifts(params)
        }
        pub fn some(value: Vec<shift::WhereParam>) -> WhereParam {
            WhereParam::ShiftsSome(value)
        }
        pub fn every(value: Vec<shift::WhereParam>) -> WhereParam {
            WhereParam::ShiftsEvery(value)
        }
        pub fn none(value: Vec<shift::WhereParam>) -> WhereParam {
            WhereParam::ShiftsNone(value)
        }
        pub enum Include {
            Select(shift::ManyArgs, Vec<shift::SelectParam>),
            Include(shift::ManyArgs, Vec<shift::IncludeParam>),
            Fetch(shift::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Shifts(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <shift::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <shift::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: shift::ManyArgs,
                nested_selections: Vec<shift::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: shift::ManyArgs,
                nested_selections: Vec<shift::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(shift::ManyArgs, Vec<shift::SelectParam>),
            Include(shift::ManyArgs, Vec<shift::IncludeParam>),
            Fetch(shift::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Shifts(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <shift::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: shift::ManyArgs,
                nested_selections: Vec<shift::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: shift::ManyArgs,
                nested_selections: Vec<shift::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod team {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "team";
        pub struct Fetch(pub team::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<team::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Team(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(team::UniqueArgs::new())
        }
        pub struct Connect(team::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectTeam(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: team::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<team::WhereParam>) -> WhereParam {
            WhereParam::TeamIs(value)
        }
        pub fn is_not(value: Vec<team::WhereParam>) -> WhereParam {
            WhereParam::TeamIsNot(value)
        }
        pub enum Include {
            Select(Vec<team::SelectParam>),
            Include(Vec<team::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Team(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <team::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <team::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("team", None, [], selections)
            }
            pub fn select(nested_selections: Vec<team::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<team::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<team::SelectParam>),
            Include(Vec<team::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Team(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <team::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("team", None, [], selections)
            }
            pub fn select(nested_selections: Vec<team::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<team::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        id: String,
        start_date: String,
        end_date: String,
        team: super::team::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        super::team::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (id, start_date, end_date, team, _params)
    }
    pub fn create_unchecked(
        id: String,
        team_id: String,
        start_date: String,
        end_date: String,
        _params: Vec<SetParam>,
    ) -> (String, String, String, String, Vec<SetParam>) {
        (id, team_id, start_date, end_date, _params)
    }
    #[macro_export]
    macro_rules ! _select_schedule { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: schedule :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: schedule :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: schedule :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: schedule :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: schedule :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: schedule :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , team_id , start_date , end_date , shifts , team } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: schedule :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: schedule :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: schedule :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: schedule :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: schedule :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: schedule :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "team_id" , "start_date" , "end_date" , "shifts" , "team"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: schedule :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; team_id) => { String } ; (@ field_type ; start_date) => { String } ; (@ field_type ; end_date) => { String } ; (@ field_type ; shifts : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < shifts :: Data > } ; (@ field_type ; shifts) => { Vec < crate :: prisma :: shift :: Data > } ; (@ field_type ; team : $ selection_mode : ident { $ ($ selections : tt) + }) => { team :: Data } ; (@ field_type ; team) => { crate :: prisma :: team :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Schedule" , available relations are "id, team_id, start_date, end_date, shifts, team")) } ; (@ field_module ; shifts : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: shift :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; team : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: team :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: schedule :: SelectParam > :: into (crate :: prisma :: schedule :: id :: Select) } ; (@ selection_field_to_selection_param ; team_id) => { Into :: < crate :: prisma :: schedule :: SelectParam > :: into (crate :: prisma :: schedule :: team_id :: Select) } ; (@ selection_field_to_selection_param ; start_date) => { Into :: < crate :: prisma :: schedule :: SelectParam > :: into (crate :: prisma :: schedule :: start_date :: Select) } ; (@ selection_field_to_selection_param ; end_date) => { Into :: < crate :: prisma :: schedule :: SelectParam > :: into (crate :: prisma :: schedule :: end_date :: Select) } ; (@ selection_field_to_selection_param ; shifts $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: schedule :: SelectParam > :: into (crate :: prisma :: schedule :: shifts :: Select :: $ selection_mode (crate :: prisma :: shift :: ManyArgs :: new (crate :: prisma :: shift :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: shift :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; shifts $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: schedule :: SelectParam > :: into (crate :: prisma :: schedule :: shifts :: Select :: Fetch (crate :: prisma :: shift :: ManyArgs :: new (crate :: prisma :: shift :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; team $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: schedule :: SelectParam > :: into (crate :: prisma :: schedule :: team :: Select :: $ selection_mode (crate :: prisma :: team :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; team $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: schedule :: SelectParam > :: into (crate :: prisma :: schedule :: team :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: schedule :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; team_id) => { "team_id" } ; (@ field_serde_name ; start_date) => { "start_date" } ; (@ field_serde_name ; end_date) => { "end_date" } ; (@ field_serde_name ; shifts) => { "shifts" } ; (@ field_serde_name ; team) => { "team" } ; }
    pub use _select_schedule as select;
    pub enum SelectParam {
        Id(id::Select),
        TeamId(team_id::Select),
        StartDate(start_date::Select),
        EndDate(end_date::Select),
        Shifts(shifts::Select),
        Team(team::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::TeamId(data) => data.to_selection(),
                Self::StartDate(data) => data.to_selection(),
                Self::EndDate(data) => data.to_selection(),
                Self::Shifts(data) => data.to_selection(),
                Self::Team(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_schedule { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: schedule :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: schedule :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: schedule :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: schedule :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: schedule :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: schedule :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: schedule :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: schedule :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { shifts , team } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub team_id : String , pub start_date : String , pub end_date : String , $ (pub $ field : crate :: prisma :: schedule :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (team_id) , stringify ! (start_date) , stringify ! (end_date)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: schedule :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: schedule :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: schedule :: team_id :: NAME , & self . team_id) ? ; state . serialize_field (crate :: prisma :: schedule :: start_date :: NAME , & self . start_date) ? ; state . serialize_field (crate :: prisma :: schedule :: end_date :: NAME , & self . end_date) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , team_id , start_date , end_date } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: schedule :: $ field :: NAME) , + , crate :: prisma :: schedule :: id :: NAME , crate :: prisma :: schedule :: team_id :: NAME , crate :: prisma :: schedule :: start_date :: NAME , crate :: prisma :: schedule :: end_date :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: schedule :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: schedule :: id :: NAME => Ok (Field :: id) , crate :: prisma :: schedule :: team_id :: NAME => Ok (Field :: team_id) , crate :: prisma :: schedule :: start_date :: NAME => Ok (Field :: start_date) , crate :: prisma :: schedule :: end_date :: NAME => Ok (Field :: end_date) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut team_id = None ; let mut start_date = None ; let mut end_date = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: schedule :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: team_id => { if team_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: schedule :: team_id :: NAME)) ; } team_id = Some (map . next_value () ?) ; } Field :: start_date => { if start_date . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: schedule :: start_date :: NAME)) ; } start_date = Some (map . next_value () ?) ; } Field :: end_date => { if end_date . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: schedule :: end_date :: NAME)) ; } end_date = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: schedule :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: schedule :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: schedule :: id :: NAME)) ? ; let team_id = team_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: schedule :: team_id :: NAME)) ? ; let start_date = start_date . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: schedule :: start_date :: NAME)) ? ; let end_date = end_date . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: schedule :: end_date :: NAME)) ? ; Ok (Data { id , team_id , start_date , end_date , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "team_id" , "start_date" , "end_date" , "shifts" , "team"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: schedule :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; shifts : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < shifts :: Data > } ; (@ field_type ; shifts) => { Vec < crate :: prisma :: shift :: Data > } ; (@ field_type ; team : $ selection_mode : ident { $ ($ selections : tt) + }) => { team :: Data } ; (@ field_type ; team) => { crate :: prisma :: team :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Schedule" , available relations are "shifts, team")) } ; (@ field_module ; shifts : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: shift :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; team : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: team :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; shifts $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: schedule :: IncludeParam > :: into (crate :: prisma :: schedule :: shifts :: Include :: $ selection_mode (crate :: prisma :: shift :: ManyArgs :: new (crate :: prisma :: shift :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: shift :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; shifts $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: schedule :: IncludeParam > :: into (crate :: prisma :: schedule :: shifts :: Include :: Fetch (crate :: prisma :: shift :: ManyArgs :: new (crate :: prisma :: shift :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; team $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: schedule :: IncludeParam > :: into (crate :: prisma :: schedule :: team :: Include :: $ selection_mode (crate :: prisma :: team :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; team $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: schedule :: IncludeParam > :: into (crate :: prisma :: schedule :: team :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: schedule :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; team_id) => { "team_id" } ; (@ field_serde_name ; start_date) => { "start_date" } ; (@ field_serde_name ; end_date) => { "end_date" } ; (@ field_serde_name ; shifts) => { "shifts" } ; (@ field_serde_name ; team) => { "team" } ; }
    pub use _include_schedule as include;
    pub enum IncludeParam {
        Id(id::Include),
        TeamId(team_id::Include),
        StartDate(start_date::Include),
        EndDate(end_date::Include),
        Shifts(shifts::Include),
        Team(team::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::TeamId(data) => data.to_selection(),
                Self::StartDate(data) => data.to_selection(),
                Self::EndDate(data) => data.to_selection(),
                Self::Shifts(data) => data.to_selection(),
                Self::Team(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_schedule { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: schedule struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "team_id")] pub team_id : String , # [serde (rename = "start_date")] pub start_date : String , # [serde (rename = "end_date")] pub end_date : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_schedule as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "team_id")]
        pub team_id: String,
        #[serde(rename = "start_date")]
        pub start_date: String,
        #[serde(rename = "end_date")]
        pub end_date: String,
        #[serde(rename = "shifts")]
        pub shifts: Option<Vec<super::shift::Data>>,
        #[serde(rename = "team")]
        pub team: Option<Box<super::team::Data>>,
    }
    impl Data {
        pub fn shifts(
            &self,
        ) -> Result<&Vec<super::shift::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.shifts
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(shifts),
                ))
        }
        pub fn team(
            &self,
        ) -> Result<&super::team::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.team
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(team),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Shifts(super::shift::ManyArgs),
        Team(super::team::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Shifts(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: shift :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        shifts::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Team(args) => {
                    let mut selections =
                        <super::team::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(team::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetTeamId(String),
        SetStartDate(String),
        SetEndDate(String),
        ConnectShifts(Vec<super::shift::UniqueWhereParam>),
        DisconnectShifts(Vec<super::shift::UniqueWhereParam>),
        SetShifts(Vec<super::shift::UniqueWhereParam>),
        ConnectTeam(super::team::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetTeamId(value) => (
                    team_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetStartDate(value) => (
                    start_date::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetEndDate(value) => (
                    end_date::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectShifts(where_params) => (
                    shifts::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::shift::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectShifts(where_params) => (
                    shifts::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::shift::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetShifts(where_params) => (
                    shifts::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::shift::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectTeam(where_param) => (
                    team::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::team::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        TeamId(String),
        StartDate(String),
        EndDate(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::TeamId(value) => Self::SetTeamId(value),
                UncheckedSetParam::StartDate(value) => Self::SetStartDate(value),
                UncheckedSetParam::EndDate(value) => Self::SetEndDate(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        TeamId(::prisma_client_rust::Direction),
        StartDate(::prisma_client_rust::Direction),
        EndDate(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::TeamId(direction) => (
                    team_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::StartDate(direction) => (
                    start_date::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::EndDate(direction) => (
                    end_date::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        TeamId(_prisma::read_filters::StringFilter),
        StartDate(_prisma::read_filters::StringFilter),
        EndDate(_prisma::read_filters::StringFilter),
        ShiftsSome(Vec<super::shift::WhereParam>),
        ShiftsEvery(Vec<super::shift::WhereParam>),
        ShiftsNone(Vec<super::shift::WhereParam>),
        TeamIs(Vec<super::team::WhereParam>),
        TeamIsNot(Vec<super::team::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::TeamId(value) => (team_id::NAME, value.into()),
                Self::StartDate(value) => (start_date::NAME, value.into()),
                Self::EndDate(value) => (end_date::NAME, value.into()),
                Self::ShiftsSome(where_params) => (
                    shifts::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ShiftsEvery(where_params) => (
                    shifts::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ShiftsNone(where_params) => (
                    shifts::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TeamIs(where_params) => (
                    team::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TeamIsNot(where_params) => (
                    team::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(team_id::NAME),
                ::prisma_client_rust::sel(start_date::NAME),
                ::prisma_client_rust::sel(end_date::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            id: String,
            start_date: String,
            end_date: String,
            team: super::team::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                id::set(id),
                start_date::set(start_date),
                end_date::set(end_date),
                team::connect(team),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            id: String,
            team_id: String,
            start_date: String,
            end_date: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                id::set(id),
                team_id::set(team_id),
                start_date::set(start_date),
                end_date::set(end_date),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(id, team_id, start_date, end_date, mut _params)| {
                    _params.extend([
                        id::set(id),
                        team_id::set(team_id),
                        start_date::set(start_date),
                        end_date::set(end_date),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (id, start_date, end_date, team, mut _params): (
                String,
                String,
                String,
                super::team::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                id::set(id),
                start_date::set(start_date),
                end_date::set(end_date),
                team::connect(team),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod shift {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Shift";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod assigned_to {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "assigned_to";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetAssignedTo(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::AssignedTo(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::AssignedTo(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::AssignedTo(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            AssignedTo,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AssignedTo(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AssignedTo(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod start_date_time {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "start_date_time";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetStartDateTime(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::StartDateTime(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::StartDateTime(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::StartDateTime(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            StartDateTime,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::StartDateTime(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::StartDateTime(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod end_date_time {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "end_date_time";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetEndDateTime(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::EndDateTime(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::EndDateTime(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::EndDateTime(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            EndDateTime,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::EndDateTime(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::EndDateTime(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod duration {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "duration";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDuration(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Duration(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Duration(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Duration(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Duration,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Duration(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Duration(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod breaks {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "breaks";
        pub struct Fetch(pub r#break::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<r#break::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: r#break::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: r#break::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Breaks(v)
            }
        }
        pub fn fetch(params: Vec<r#break::WhereParam>) -> Fetch {
            Fetch(r#break::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<r#break::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBreaks(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<r#break::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<r#break::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectBreaks(params)
        }
        pub fn set(params: Vec<r#break::UniqueWhereParam>) -> SetParam {
            SetParam::SetBreaks(params)
        }
        pub fn some(value: Vec<r#break::WhereParam>) -> WhereParam {
            WhereParam::BreaksSome(value)
        }
        pub fn every(value: Vec<r#break::WhereParam>) -> WhereParam {
            WhereParam::BreaksEvery(value)
        }
        pub fn none(value: Vec<r#break::WhereParam>) -> WhereParam {
            WhereParam::BreaksNone(value)
        }
        pub enum Include {
            Select(r#break::ManyArgs, Vec<r#break::SelectParam>),
            Include(r#break::ManyArgs, Vec<r#break::IncludeParam>),
            Fetch(r#break::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Breaks(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <r#break::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <r#break::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: r#break::ManyArgs,
                nested_selections: Vec<r#break::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: r#break::ManyArgs,
                nested_selections: Vec<r#break::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(r#break::ManyArgs, Vec<r#break::SelectParam>),
            Include(r#break::ManyArgs, Vec<r#break::IncludeParam>),
            Fetch(r#break::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Breaks(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <r#break::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: r#break::ManyArgs,
                nested_selections: Vec<r#break::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: r#break::ManyArgs,
                nested_selections: Vec<r#break::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod is_open {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "is_open";
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetIsOpen(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::IsOpen(v)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::IsOpen(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::IsOpen(_prisma::read_filters::BoolFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BoolFilter, IsOpen, {
            fn not(_: bool) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::IsOpen(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::IsOpen(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod is_close {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "is_close";
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetIsClose(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::IsClose(v)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::IsClose(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::IsClose(_prisma::read_filters::BoolFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BoolFilter,
            IsClose,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::IsClose(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::IsClose(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod is_double {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "is_double";
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetIsDouble(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::IsDouble(v)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::IsDouble(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::IsDouble(_prisma::read_filters::BoolFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BoolFilter,
            IsDouble,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::IsDouble(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::IsDouble(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod schedule_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "schedule_id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetScheduleId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ScheduleId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ScheduleId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ScheduleId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            ScheduleId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ScheduleId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ScheduleId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod schedule {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "schedule";
        pub struct Fetch(pub schedule::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<schedule::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Schedule(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(schedule::UniqueArgs::new())
        }
        pub struct Connect(schedule::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectSchedule(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: schedule::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<schedule::WhereParam>) -> WhereParam {
            WhereParam::ScheduleIs(value)
        }
        pub fn is_not(value: Vec<schedule::WhereParam>) -> WhereParam {
            WhereParam::ScheduleIsNot(value)
        }
        pub enum Include {
            Select(Vec<schedule::SelectParam>),
            Include(Vec<schedule::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Schedule(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < schedule :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <schedule::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("schedule", None, [], selections)
            }
            pub fn select(nested_selections: Vec<schedule::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<schedule::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<schedule::SelectParam>),
            Include(Vec<schedule::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Schedule(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <schedule::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("schedule", None, [], selections)
            }
            pub fn select(nested_selections: Vec<schedule::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<schedule::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        id: String,
        assigned_to: String,
        start_date_time: String,
        end_date_time: String,
        duration: String,
        is_open: bool,
        is_close: bool,
        is_double: bool,
        schedule: super::schedule::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        String,
        String,
        bool,
        bool,
        bool,
        super::schedule::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (
            id,
            assigned_to,
            start_date_time,
            end_date_time,
            duration,
            is_open,
            is_close,
            is_double,
            schedule,
            _params,
        )
    }
    pub fn create_unchecked(
        id: String,
        assigned_to: String,
        start_date_time: String,
        end_date_time: String,
        duration: String,
        is_open: bool,
        is_close: bool,
        is_double: bool,
        schedule_id: String,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        String,
        String,
        bool,
        bool,
        bool,
        String,
        Vec<SetParam>,
    ) {
        (
            id,
            assigned_to,
            start_date_time,
            end_date_time,
            duration,
            is_open,
            is_close,
            is_double,
            schedule_id,
            _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_shift { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: shift :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: shift :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: shift :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: shift :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: shift :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: shift :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , assigned_to , start_date_time , end_date_time , duration , breaks , is_open , is_close , is_double , schedule_id , schedule } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: shift :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: shift :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: shift :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: shift :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shift :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shift :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "assigned_to" , "start_date_time" , "end_date_time" , "duration" , "breaks" , "is_open" , "is_close" , "is_double" , "schedule_id" , "schedule"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: shift :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; assigned_to) => { String } ; (@ field_type ; start_date_time) => { String } ; (@ field_type ; end_date_time) => { String } ; (@ field_type ; duration) => { String } ; (@ field_type ; breaks : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < breaks :: Data > } ; (@ field_type ; breaks) => { Vec < crate :: prisma :: r#break :: Data > } ; (@ field_type ; is_open) => { bool } ; (@ field_type ; is_close) => { bool } ; (@ field_type ; is_double) => { bool } ; (@ field_type ; schedule_id) => { String } ; (@ field_type ; schedule : $ selection_mode : ident { $ ($ selections : tt) + }) => { schedule :: Data } ; (@ field_type ; schedule) => { crate :: prisma :: schedule :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Shift" , available relations are "id, assigned_to, start_date_time, end_date_time, duration, breaks, is_open, is_close, is_double, schedule_id, schedule")) } ; (@ field_module ; breaks : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: r#break :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; schedule : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: schedule :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: shift :: SelectParam > :: into (crate :: prisma :: shift :: id :: Select) } ; (@ selection_field_to_selection_param ; assigned_to) => { Into :: < crate :: prisma :: shift :: SelectParam > :: into (crate :: prisma :: shift :: assigned_to :: Select) } ; (@ selection_field_to_selection_param ; start_date_time) => { Into :: < crate :: prisma :: shift :: SelectParam > :: into (crate :: prisma :: shift :: start_date_time :: Select) } ; (@ selection_field_to_selection_param ; end_date_time) => { Into :: < crate :: prisma :: shift :: SelectParam > :: into (crate :: prisma :: shift :: end_date_time :: Select) } ; (@ selection_field_to_selection_param ; duration) => { Into :: < crate :: prisma :: shift :: SelectParam > :: into (crate :: prisma :: shift :: duration :: Select) } ; (@ selection_field_to_selection_param ; breaks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: shift :: SelectParam > :: into (crate :: prisma :: shift :: breaks :: Select :: $ selection_mode (crate :: prisma :: r#break :: ManyArgs :: new (crate :: prisma :: r#break :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: r#break :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; breaks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: shift :: SelectParam > :: into (crate :: prisma :: shift :: breaks :: Select :: Fetch (crate :: prisma :: r#break :: ManyArgs :: new (crate :: prisma :: r#break :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; is_open) => { Into :: < crate :: prisma :: shift :: SelectParam > :: into (crate :: prisma :: shift :: is_open :: Select) } ; (@ selection_field_to_selection_param ; is_close) => { Into :: < crate :: prisma :: shift :: SelectParam > :: into (crate :: prisma :: shift :: is_close :: Select) } ; (@ selection_field_to_selection_param ; is_double) => { Into :: < crate :: prisma :: shift :: SelectParam > :: into (crate :: prisma :: shift :: is_double :: Select) } ; (@ selection_field_to_selection_param ; schedule_id) => { Into :: < crate :: prisma :: shift :: SelectParam > :: into (crate :: prisma :: shift :: schedule_id :: Select) } ; (@ selection_field_to_selection_param ; schedule $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: shift :: SelectParam > :: into (crate :: prisma :: shift :: schedule :: Select :: $ selection_mode (crate :: prisma :: schedule :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; schedule $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: shift :: SelectParam > :: into (crate :: prisma :: shift :: schedule :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: shift :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; assigned_to) => { "assigned_to" } ; (@ field_serde_name ; start_date_time) => { "start_date_time" } ; (@ field_serde_name ; end_date_time) => { "end_date_time" } ; (@ field_serde_name ; duration) => { "duration" } ; (@ field_serde_name ; breaks) => { "breaks" } ; (@ field_serde_name ; is_open) => { "is_open" } ; (@ field_serde_name ; is_close) => { "is_close" } ; (@ field_serde_name ; is_double) => { "is_double" } ; (@ field_serde_name ; schedule_id) => { "schedule_id" } ; (@ field_serde_name ; schedule) => { "schedule" } ; }
    pub use _select_shift as select;
    pub enum SelectParam {
        Id(id::Select),
        AssignedTo(assigned_to::Select),
        StartDateTime(start_date_time::Select),
        EndDateTime(end_date_time::Select),
        Duration(duration::Select),
        Breaks(breaks::Select),
        IsOpen(is_open::Select),
        IsClose(is_close::Select),
        IsDouble(is_double::Select),
        ScheduleId(schedule_id::Select),
        Schedule(schedule::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::AssignedTo(data) => data.to_selection(),
                Self::StartDateTime(data) => data.to_selection(),
                Self::EndDateTime(data) => data.to_selection(),
                Self::Duration(data) => data.to_selection(),
                Self::Breaks(data) => data.to_selection(),
                Self::IsOpen(data) => data.to_selection(),
                Self::IsClose(data) => data.to_selection(),
                Self::IsDouble(data) => data.to_selection(),
                Self::ScheduleId(data) => data.to_selection(),
                Self::Schedule(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_shift { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: shift :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: shift :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: shift :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: shift :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: shift :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: shift :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: shift :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: shift :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { breaks , schedule } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub assigned_to : String , pub start_date_time : String , pub end_date_time : String , pub duration : String , pub is_open : bool , pub is_close : bool , pub is_double : bool , pub schedule_id : String , $ (pub $ field : crate :: prisma :: shift :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (assigned_to) , stringify ! (start_date_time) , stringify ! (end_date_time) , stringify ! (duration) , stringify ! (is_open) , stringify ! (is_close) , stringify ! (is_double) , stringify ! (schedule_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: shift :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: shift :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: shift :: assigned_to :: NAME , & self . assigned_to) ? ; state . serialize_field (crate :: prisma :: shift :: start_date_time :: NAME , & self . start_date_time) ? ; state . serialize_field (crate :: prisma :: shift :: end_date_time :: NAME , & self . end_date_time) ? ; state . serialize_field (crate :: prisma :: shift :: duration :: NAME , & self . duration) ? ; state . serialize_field (crate :: prisma :: shift :: is_open :: NAME , & self . is_open) ? ; state . serialize_field (crate :: prisma :: shift :: is_close :: NAME , & self . is_close) ? ; state . serialize_field (crate :: prisma :: shift :: is_double :: NAME , & self . is_double) ? ; state . serialize_field (crate :: prisma :: shift :: schedule_id :: NAME , & self . schedule_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , assigned_to , start_date_time , end_date_time , duration , is_open , is_close , is_double , schedule_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: shift :: $ field :: NAME) , + , crate :: prisma :: shift :: id :: NAME , crate :: prisma :: shift :: assigned_to :: NAME , crate :: prisma :: shift :: start_date_time :: NAME , crate :: prisma :: shift :: end_date_time :: NAME , crate :: prisma :: shift :: duration :: NAME , crate :: prisma :: shift :: is_open :: NAME , crate :: prisma :: shift :: is_close :: NAME , crate :: prisma :: shift :: is_double :: NAME , crate :: prisma :: shift :: schedule_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: shift :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: shift :: id :: NAME => Ok (Field :: id) , crate :: prisma :: shift :: assigned_to :: NAME => Ok (Field :: assigned_to) , crate :: prisma :: shift :: start_date_time :: NAME => Ok (Field :: start_date_time) , crate :: prisma :: shift :: end_date_time :: NAME => Ok (Field :: end_date_time) , crate :: prisma :: shift :: duration :: NAME => Ok (Field :: duration) , crate :: prisma :: shift :: is_open :: NAME => Ok (Field :: is_open) , crate :: prisma :: shift :: is_close :: NAME => Ok (Field :: is_close) , crate :: prisma :: shift :: is_double :: NAME => Ok (Field :: is_double) , crate :: prisma :: shift :: schedule_id :: NAME => Ok (Field :: schedule_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut assigned_to = None ; let mut start_date_time = None ; let mut end_date_time = None ; let mut duration = None ; let mut is_open = None ; let mut is_close = None ; let mut is_double = None ; let mut schedule_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shift :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: assigned_to => { if assigned_to . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shift :: assigned_to :: NAME)) ; } assigned_to = Some (map . next_value () ?) ; } Field :: start_date_time => { if start_date_time . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shift :: start_date_time :: NAME)) ; } start_date_time = Some (map . next_value () ?) ; } Field :: end_date_time => { if end_date_time . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shift :: end_date_time :: NAME)) ; } end_date_time = Some (map . next_value () ?) ; } Field :: duration => { if duration . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shift :: duration :: NAME)) ; } duration = Some (map . next_value () ?) ; } Field :: is_open => { if is_open . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shift :: is_open :: NAME)) ; } is_open = Some (map . next_value () ?) ; } Field :: is_close => { if is_close . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shift :: is_close :: NAME)) ; } is_close = Some (map . next_value () ?) ; } Field :: is_double => { if is_double . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shift :: is_double :: NAME)) ; } is_double = Some (map . next_value () ?) ; } Field :: schedule_id => { if schedule_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shift :: schedule_id :: NAME)) ; } schedule_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shift :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shift :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shift :: id :: NAME)) ? ; let assigned_to = assigned_to . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shift :: assigned_to :: NAME)) ? ; let start_date_time = start_date_time . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shift :: start_date_time :: NAME)) ? ; let end_date_time = end_date_time . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shift :: end_date_time :: NAME)) ? ; let duration = duration . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shift :: duration :: NAME)) ? ; let is_open = is_open . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shift :: is_open :: NAME)) ? ; let is_close = is_close . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shift :: is_close :: NAME)) ? ; let is_double = is_double . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shift :: is_double :: NAME)) ? ; let schedule_id = schedule_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shift :: schedule_id :: NAME)) ? ; Ok (Data { id , assigned_to , start_date_time , end_date_time , duration , is_open , is_close , is_double , schedule_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "assigned_to" , "start_date_time" , "end_date_time" , "duration" , "breaks" , "is_open" , "is_close" , "is_double" , "schedule_id" , "schedule"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: shift :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; breaks : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < breaks :: Data > } ; (@ field_type ; breaks) => { Vec < crate :: prisma :: r#break :: Data > } ; (@ field_type ; schedule : $ selection_mode : ident { $ ($ selections : tt) + }) => { schedule :: Data } ; (@ field_type ; schedule) => { crate :: prisma :: schedule :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Shift" , available relations are "breaks, schedule")) } ; (@ field_module ; breaks : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: r#break :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; schedule : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: schedule :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; breaks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: shift :: IncludeParam > :: into (crate :: prisma :: shift :: breaks :: Include :: $ selection_mode (crate :: prisma :: r#break :: ManyArgs :: new (crate :: prisma :: r#break :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: r#break :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; breaks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: shift :: IncludeParam > :: into (crate :: prisma :: shift :: breaks :: Include :: Fetch (crate :: prisma :: r#break :: ManyArgs :: new (crate :: prisma :: r#break :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; schedule $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: shift :: IncludeParam > :: into (crate :: prisma :: shift :: schedule :: Include :: $ selection_mode (crate :: prisma :: schedule :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; schedule $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: shift :: IncludeParam > :: into (crate :: prisma :: shift :: schedule :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: shift :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; assigned_to) => { "assigned_to" } ; (@ field_serde_name ; start_date_time) => { "start_date_time" } ; (@ field_serde_name ; end_date_time) => { "end_date_time" } ; (@ field_serde_name ; duration) => { "duration" } ; (@ field_serde_name ; breaks) => { "breaks" } ; (@ field_serde_name ; is_open) => { "is_open" } ; (@ field_serde_name ; is_close) => { "is_close" } ; (@ field_serde_name ; is_double) => { "is_double" } ; (@ field_serde_name ; schedule_id) => { "schedule_id" } ; (@ field_serde_name ; schedule) => { "schedule" } ; }
    pub use _include_shift as include;
    pub enum IncludeParam {
        Id(id::Include),
        AssignedTo(assigned_to::Include),
        StartDateTime(start_date_time::Include),
        EndDateTime(end_date_time::Include),
        Duration(duration::Include),
        Breaks(breaks::Include),
        IsOpen(is_open::Include),
        IsClose(is_close::Include),
        IsDouble(is_double::Include),
        ScheduleId(schedule_id::Include),
        Schedule(schedule::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::AssignedTo(data) => data.to_selection(),
                Self::StartDateTime(data) => data.to_selection(),
                Self::EndDateTime(data) => data.to_selection(),
                Self::Duration(data) => data.to_selection(),
                Self::Breaks(data) => data.to_selection(),
                Self::IsOpen(data) => data.to_selection(),
                Self::IsClose(data) => data.to_selection(),
                Self::IsDouble(data) => data.to_selection(),
                Self::ScheduleId(data) => data.to_selection(),
                Self::Schedule(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_shift { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: shift struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "assigned_to")] pub assigned_to : String , # [serde (rename = "start_date_time")] pub start_date_time : String , # [serde (rename = "end_date_time")] pub end_date_time : String , # [serde (rename = "duration")] pub duration : String , # [serde (rename = "is_open")] pub is_open : bool , # [serde (rename = "is_close")] pub is_close : bool , # [serde (rename = "is_double")] pub is_double : bool , # [serde (rename = "schedule_id")] pub schedule_id : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_shift as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "assigned_to")]
        pub assigned_to: String,
        #[serde(rename = "start_date_time")]
        pub start_date_time: String,
        #[serde(rename = "end_date_time")]
        pub end_date_time: String,
        #[serde(rename = "duration")]
        pub duration: String,
        #[serde(rename = "breaks")]
        pub breaks: Option<Vec<super::r#break::Data>>,
        #[serde(rename = "is_open")]
        pub is_open: bool,
        #[serde(rename = "is_close")]
        pub is_close: bool,
        #[serde(rename = "is_double")]
        pub is_double: bool,
        #[serde(rename = "schedule_id")]
        pub schedule_id: String,
        #[serde(rename = "schedule")]
        pub schedule: Option<Box<super::schedule::Data>>,
    }
    impl Data {
        pub fn breaks(
            &self,
        ) -> Result<&Vec<super::r#break::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.breaks
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(breaks),
                ))
        }
        pub fn schedule(
            &self,
        ) -> Result<&super::schedule::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.schedule
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(schedule),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Breaks(super::r#break::ManyArgs),
        Schedule(super::schedule::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Breaks(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: r#break :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        breaks::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Schedule(args) => {
                    let mut selections = < super :: schedule :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(schedule::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetAssignedTo(String),
        SetStartDateTime(String),
        SetEndDateTime(String),
        SetDuration(String),
        ConnectBreaks(Vec<super::r#break::UniqueWhereParam>),
        DisconnectBreaks(Vec<super::r#break::UniqueWhereParam>),
        SetBreaks(Vec<super::r#break::UniqueWhereParam>),
        SetIsOpen(bool),
        SetIsClose(bool),
        SetIsDouble(bool),
        SetScheduleId(String),
        ConnectSchedule(super::schedule::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetAssignedTo(value) => (
                    assigned_to::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetStartDateTime(value) => (
                    start_date_time::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetEndDateTime(value) => (
                    end_date_time::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetDuration(value) => (
                    duration::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectBreaks(where_params) => (
                    breaks::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::r#break::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectBreaks(where_params) => (
                    breaks::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::r#break::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetBreaks(where_params) => (
                    breaks::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::r#break::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetIsOpen(value) => (
                    is_open::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetIsClose(value) => (
                    is_close::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetIsDouble(value) => (
                    is_double::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetScheduleId(value) => (
                    schedule_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectSchedule(where_param) => (
                    schedule::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::schedule::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        AssignedTo(String),
        StartDateTime(String),
        EndDateTime(String),
        Duration(String),
        IsOpen(bool),
        IsClose(bool),
        IsDouble(bool),
        ScheduleId(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::AssignedTo(value) => Self::SetAssignedTo(value),
                UncheckedSetParam::StartDateTime(value) => Self::SetStartDateTime(value),
                UncheckedSetParam::EndDateTime(value) => Self::SetEndDateTime(value),
                UncheckedSetParam::Duration(value) => Self::SetDuration(value),
                UncheckedSetParam::IsOpen(value) => Self::SetIsOpen(value),
                UncheckedSetParam::IsClose(value) => Self::SetIsClose(value),
                UncheckedSetParam::IsDouble(value) => Self::SetIsDouble(value),
                UncheckedSetParam::ScheduleId(value) => Self::SetScheduleId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        AssignedTo(::prisma_client_rust::Direction),
        StartDateTime(::prisma_client_rust::Direction),
        EndDateTime(::prisma_client_rust::Direction),
        Duration(::prisma_client_rust::Direction),
        IsOpen(::prisma_client_rust::Direction),
        IsClose(::prisma_client_rust::Direction),
        IsDouble(::prisma_client_rust::Direction),
        ScheduleId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::AssignedTo(direction) => (
                    assigned_to::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::StartDateTime(direction) => (
                    start_date_time::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::EndDateTime(direction) => (
                    end_date_time::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Duration(direction) => (
                    duration::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::IsOpen(direction) => (
                    is_open::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::IsClose(direction) => (
                    is_close::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::IsDouble(direction) => (
                    is_double::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ScheduleId(direction) => (
                    schedule_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        AssignedTo(_prisma::read_filters::StringFilter),
        StartDateTime(_prisma::read_filters::StringFilter),
        EndDateTime(_prisma::read_filters::StringFilter),
        Duration(_prisma::read_filters::StringFilter),
        BreaksSome(Vec<super::r#break::WhereParam>),
        BreaksEvery(Vec<super::r#break::WhereParam>),
        BreaksNone(Vec<super::r#break::WhereParam>),
        IsOpen(_prisma::read_filters::BoolFilter),
        IsClose(_prisma::read_filters::BoolFilter),
        IsDouble(_prisma::read_filters::BoolFilter),
        ScheduleId(_prisma::read_filters::StringFilter),
        ScheduleIs(Vec<super::schedule::WhereParam>),
        ScheduleIsNot(Vec<super::schedule::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::AssignedTo(value) => (assigned_to::NAME, value.into()),
                Self::StartDateTime(value) => (start_date_time::NAME, value.into()),
                Self::EndDateTime(value) => (end_date_time::NAME, value.into()),
                Self::Duration(value) => (duration::NAME, value.into()),
                Self::BreaksSome(where_params) => (
                    breaks::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BreaksEvery(where_params) => (
                    breaks::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BreaksNone(where_params) => (
                    breaks::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::IsOpen(value) => (is_open::NAME, value.into()),
                Self::IsClose(value) => (is_close::NAME, value.into()),
                Self::IsDouble(value) => (is_double::NAME, value.into()),
                Self::ScheduleId(value) => (schedule_id::NAME, value.into()),
                Self::ScheduleIs(where_params) => (
                    schedule::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ScheduleIsNot(where_params) => (
                    schedule::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(assigned_to::NAME),
                ::prisma_client_rust::sel(start_date_time::NAME),
                ::prisma_client_rust::sel(end_date_time::NAME),
                ::prisma_client_rust::sel(duration::NAME),
                ::prisma_client_rust::sel(is_open::NAME),
                ::prisma_client_rust::sel(is_close::NAME),
                ::prisma_client_rust::sel(is_double::NAME),
                ::prisma_client_rust::sel(schedule_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            id: String,
            assigned_to: String,
            start_date_time: String,
            end_date_time: String,
            duration: String,
            is_open: bool,
            is_close: bool,
            is_double: bool,
            schedule: super::schedule::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                id::set(id),
                assigned_to::set(assigned_to),
                start_date_time::set(start_date_time),
                end_date_time::set(end_date_time),
                duration::set(duration),
                is_open::set(is_open),
                is_close::set(is_close),
                is_double::set(is_double),
                schedule::connect(schedule),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            id: String,
            assigned_to: String,
            start_date_time: String,
            end_date_time: String,
            duration: String,
            is_open: bool,
            is_close: bool,
            is_double: bool,
            schedule_id: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                id::set(id),
                assigned_to::set(assigned_to),
                start_date_time::set(start_date_time),
                end_date_time::set(end_date_time),
                duration::set(duration),
                is_open::set(is_open),
                is_close::set(is_close),
                is_double::set(is_double),
                schedule_id::set(schedule_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(
                String,
                String,
                String,
                String,
                String,
                bool,
                bool,
                bool,
                String,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(
                        id,
                        assigned_to,
                        start_date_time,
                        end_date_time,
                        duration,
                        is_open,
                        is_close,
                        is_double,
                        schedule_id,
                        mut _params,
                    )| {
                        _params.extend([
                            id::set(id),
                            assigned_to::set(assigned_to),
                            start_date_time::set(start_date_time),
                            end_date_time::set(end_date_time),
                            duration::set(duration),
                            is_open::set(is_open),
                            is_close::set(is_close),
                            is_double::set(is_double),
                            schedule_id::set(schedule_id),
                        ]);
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (
                id,
                assigned_to,
                start_date_time,
                end_date_time,
                duration,
                is_open,
                is_close,
                is_double,
                schedule,
                mut _params,
            ): (
                String,
                String,
                String,
                String,
                String,
                bool,
                bool,
                bool,
                super::schedule::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                id::set(id),
                assigned_to::set(assigned_to),
                start_date_time::set(start_date_time),
                end_date_time::set(end_date_time),
                duration::set(duration),
                is_open::set(is_open),
                is_close::set(is_close),
                is_double::set(is_double),
                schedule::connect(schedule),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod r#break {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Break";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod start_date_time {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "start_date_time";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetStartDateTime(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::StartDateTime(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::StartDateTime(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::StartDateTime(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            StartDateTime,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::StartDateTime(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::StartDateTime(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod end_date_time {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "end_date_time";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetEndDateTime(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::EndDateTime(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::EndDateTime(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::EndDateTime(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            EndDateTime,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::EndDateTime(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::EndDateTime(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod duration {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "duration";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDuration(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Duration(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Duration(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Duration(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Duration,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Duration(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Duration(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod is_meal {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "is_meal";
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetIsMeal(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::IsMeal(v)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::IsMeal(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::IsMeal(_prisma::read_filters::BoolFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BoolFilter, IsMeal, {
            fn not(_: bool) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::IsMeal(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::IsMeal(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod shift_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "shift_id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetShiftId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ShiftId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ShiftId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ShiftId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            ShiftId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ShiftId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ShiftId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod shift {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "shift";
        pub struct Fetch(pub shift::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<shift::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Shift(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(shift::UniqueArgs::new())
        }
        pub struct Connect(shift::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectShift(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: shift::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<shift::WhereParam>) -> WhereParam {
            WhereParam::ShiftIs(value)
        }
        pub fn is_not(value: Vec<shift::WhereParam>) -> WhereParam {
            WhereParam::ShiftIsNot(value)
        }
        pub enum Include {
            Select(Vec<shift::SelectParam>),
            Include(Vec<shift::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Shift(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <shift::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <shift::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("shift", None, [], selections)
            }
            pub fn select(nested_selections: Vec<shift::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<shift::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<shift::SelectParam>),
            Include(Vec<shift::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Shift(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <shift::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("shift", None, [], selections)
            }
            pub fn select(nested_selections: Vec<shift::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<shift::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        id: String,
        start_date_time: String,
        end_date_time: String,
        duration: String,
        is_meal: bool,
        shift: super::shift::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        String,
        bool,
        super::shift::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (
            id,
            start_date_time,
            end_date_time,
            duration,
            is_meal,
            shift,
            _params,
        )
    }
    pub fn create_unchecked(
        id: String,
        start_date_time: String,
        end_date_time: String,
        duration: String,
        is_meal: bool,
        shift_id: String,
        _params: Vec<SetParam>,
    ) -> (String, String, String, String, bool, String, Vec<SetParam>) {
        (
            id,
            start_date_time,
            end_date_time,
            duration,
            is_meal,
            shift_id,
            _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_break { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: r#break :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: r#break :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: r#break :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: r#break :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: r#break :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: r#break :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , start_date_time , end_date_time , duration , is_meal , shift_id , shift } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: r#break :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: r#break :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: r#break :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: r#break :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: r#break :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: r#break :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "start_date_time" , "end_date_time" , "duration" , "is_meal" , "shift_id" , "shift"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: r#break :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; start_date_time) => { String } ; (@ field_type ; end_date_time) => { String } ; (@ field_type ; duration) => { String } ; (@ field_type ; is_meal) => { bool } ; (@ field_type ; shift_id) => { String } ; (@ field_type ; shift : $ selection_mode : ident { $ ($ selections : tt) + }) => { shift :: Data } ; (@ field_type ; shift) => { crate :: prisma :: shift :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Break" , available relations are "id, start_date_time, end_date_time, duration, is_meal, shift_id, shift")) } ; (@ field_module ; shift : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: shift :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: r#break :: SelectParam > :: into (crate :: prisma :: r#break :: id :: Select) } ; (@ selection_field_to_selection_param ; start_date_time) => { Into :: < crate :: prisma :: r#break :: SelectParam > :: into (crate :: prisma :: r#break :: start_date_time :: Select) } ; (@ selection_field_to_selection_param ; end_date_time) => { Into :: < crate :: prisma :: r#break :: SelectParam > :: into (crate :: prisma :: r#break :: end_date_time :: Select) } ; (@ selection_field_to_selection_param ; duration) => { Into :: < crate :: prisma :: r#break :: SelectParam > :: into (crate :: prisma :: r#break :: duration :: Select) } ; (@ selection_field_to_selection_param ; is_meal) => { Into :: < crate :: prisma :: r#break :: SelectParam > :: into (crate :: prisma :: r#break :: is_meal :: Select) } ; (@ selection_field_to_selection_param ; shift_id) => { Into :: < crate :: prisma :: r#break :: SelectParam > :: into (crate :: prisma :: r#break :: shift_id :: Select) } ; (@ selection_field_to_selection_param ; shift $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: r#break :: SelectParam > :: into (crate :: prisma :: r#break :: shift :: Select :: $ selection_mode (crate :: prisma :: shift :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; shift $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: r#break :: SelectParam > :: into (crate :: prisma :: r#break :: shift :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: r#break :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; start_date_time) => { "start_date_time" } ; (@ field_serde_name ; end_date_time) => { "end_date_time" } ; (@ field_serde_name ; duration) => { "duration" } ; (@ field_serde_name ; is_meal) => { "is_meal" } ; (@ field_serde_name ; shift_id) => { "shift_id" } ; (@ field_serde_name ; shift) => { "shift" } ; }
    pub use _select_break as select;
    pub enum SelectParam {
        Id(id::Select),
        StartDateTime(start_date_time::Select),
        EndDateTime(end_date_time::Select),
        Duration(duration::Select),
        IsMeal(is_meal::Select),
        ShiftId(shift_id::Select),
        Shift(shift::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::StartDateTime(data) => data.to_selection(),
                Self::EndDateTime(data) => data.to_selection(),
                Self::Duration(data) => data.to_selection(),
                Self::IsMeal(data) => data.to_selection(),
                Self::ShiftId(data) => data.to_selection(),
                Self::Shift(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_break { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: r#break :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: r#break :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: r#break :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: r#break :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: r#break :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: r#break :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: r#break :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: r#break :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { shift } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub start_date_time : String , pub end_date_time : String , pub duration : String , pub is_meal : bool , pub shift_id : String , $ (pub $ field : crate :: prisma :: r#break :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (start_date_time) , stringify ! (end_date_time) , stringify ! (duration) , stringify ! (is_meal) , stringify ! (shift_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: r#break :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: r#break :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: r#break :: start_date_time :: NAME , & self . start_date_time) ? ; state . serialize_field (crate :: prisma :: r#break :: end_date_time :: NAME , & self . end_date_time) ? ; state . serialize_field (crate :: prisma :: r#break :: duration :: NAME , & self . duration) ? ; state . serialize_field (crate :: prisma :: r#break :: is_meal :: NAME , & self . is_meal) ? ; state . serialize_field (crate :: prisma :: r#break :: shift_id :: NAME , & self . shift_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , start_date_time , end_date_time , duration , is_meal , shift_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: r#break :: $ field :: NAME) , + , crate :: prisma :: r#break :: id :: NAME , crate :: prisma :: r#break :: start_date_time :: NAME , crate :: prisma :: r#break :: end_date_time :: NAME , crate :: prisma :: r#break :: duration :: NAME , crate :: prisma :: r#break :: is_meal :: NAME , crate :: prisma :: r#break :: shift_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: r#break :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: r#break :: id :: NAME => Ok (Field :: id) , crate :: prisma :: r#break :: start_date_time :: NAME => Ok (Field :: start_date_time) , crate :: prisma :: r#break :: end_date_time :: NAME => Ok (Field :: end_date_time) , crate :: prisma :: r#break :: duration :: NAME => Ok (Field :: duration) , crate :: prisma :: r#break :: is_meal :: NAME => Ok (Field :: is_meal) , crate :: prisma :: r#break :: shift_id :: NAME => Ok (Field :: shift_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut start_date_time = None ; let mut end_date_time = None ; let mut duration = None ; let mut is_meal = None ; let mut shift_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: r#break :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: start_date_time => { if start_date_time . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: r#break :: start_date_time :: NAME)) ; } start_date_time = Some (map . next_value () ?) ; } Field :: end_date_time => { if end_date_time . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: r#break :: end_date_time :: NAME)) ; } end_date_time = Some (map . next_value () ?) ; } Field :: duration => { if duration . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: r#break :: duration :: NAME)) ; } duration = Some (map . next_value () ?) ; } Field :: is_meal => { if is_meal . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: r#break :: is_meal :: NAME)) ; } is_meal = Some (map . next_value () ?) ; } Field :: shift_id => { if shift_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: r#break :: shift_id :: NAME)) ; } shift_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: r#break :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: r#break :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: r#break :: id :: NAME)) ? ; let start_date_time = start_date_time . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: r#break :: start_date_time :: NAME)) ? ; let end_date_time = end_date_time . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: r#break :: end_date_time :: NAME)) ? ; let duration = duration . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: r#break :: duration :: NAME)) ? ; let is_meal = is_meal . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: r#break :: is_meal :: NAME)) ? ; let shift_id = shift_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: r#break :: shift_id :: NAME)) ? ; Ok (Data { id , start_date_time , end_date_time , duration , is_meal , shift_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "start_date_time" , "end_date_time" , "duration" , "is_meal" , "shift_id" , "shift"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: r#break :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; shift : $ selection_mode : ident { $ ($ selections : tt) + }) => { shift :: Data } ; (@ field_type ; shift) => { crate :: prisma :: shift :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Break" , available relations are "shift")) } ; (@ field_module ; shift : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: shift :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; shift $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: r#break :: IncludeParam > :: into (crate :: prisma :: r#break :: shift :: Include :: $ selection_mode (crate :: prisma :: shift :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; shift $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: r#break :: IncludeParam > :: into (crate :: prisma :: r#break :: shift :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: r#break :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; start_date_time) => { "start_date_time" } ; (@ field_serde_name ; end_date_time) => { "end_date_time" } ; (@ field_serde_name ; duration) => { "duration" } ; (@ field_serde_name ; is_meal) => { "is_meal" } ; (@ field_serde_name ; shift_id) => { "shift_id" } ; (@ field_serde_name ; shift) => { "shift" } ; }
    pub use _include_break as include;
    pub enum IncludeParam {
        Id(id::Include),
        StartDateTime(start_date_time::Include),
        EndDateTime(end_date_time::Include),
        Duration(duration::Include),
        IsMeal(is_meal::Include),
        ShiftId(shift_id::Include),
        Shift(shift::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::StartDateTime(data) => data.to_selection(),
                Self::EndDateTime(data) => data.to_selection(),
                Self::Duration(data) => data.to_selection(),
                Self::IsMeal(data) => data.to_selection(),
                Self::ShiftId(data) => data.to_selection(),
                Self::Shift(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_break { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: r#break struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "start_date_time")] pub start_date_time : String , # [serde (rename = "end_date_time")] pub end_date_time : String , # [serde (rename = "duration")] pub duration : String , # [serde (rename = "is_meal")] pub is_meal : bool , # [serde (rename = "shift_id")] pub shift_id : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_break as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "start_date_time")]
        pub start_date_time: String,
        #[serde(rename = "end_date_time")]
        pub end_date_time: String,
        #[serde(rename = "duration")]
        pub duration: String,
        #[serde(rename = "is_meal")]
        pub is_meal: bool,
        #[serde(rename = "shift_id")]
        pub shift_id: String,
        #[serde(rename = "shift")]
        pub shift: Option<Box<super::shift::Data>>,
    }
    impl Data {
        pub fn shift(
            &self,
        ) -> Result<&super::shift::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.shift
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(shift),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Shift(super::shift::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Shift(args) => {
                    let mut selections = < super :: shift :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(shift::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetStartDateTime(String),
        SetEndDateTime(String),
        SetDuration(String),
        SetIsMeal(bool),
        SetShiftId(String),
        ConnectShift(super::shift::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetStartDateTime(value) => (
                    start_date_time::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetEndDateTime(value) => (
                    end_date_time::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetDuration(value) => (
                    duration::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetIsMeal(value) => (
                    is_meal::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetShiftId(value) => (
                    shift_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectShift(where_param) => (
                    shift::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::shift::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        StartDateTime(String),
        EndDateTime(String),
        Duration(String),
        IsMeal(bool),
        ShiftId(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::StartDateTime(value) => Self::SetStartDateTime(value),
                UncheckedSetParam::EndDateTime(value) => Self::SetEndDateTime(value),
                UncheckedSetParam::Duration(value) => Self::SetDuration(value),
                UncheckedSetParam::IsMeal(value) => Self::SetIsMeal(value),
                UncheckedSetParam::ShiftId(value) => Self::SetShiftId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        StartDateTime(::prisma_client_rust::Direction),
        EndDateTime(::prisma_client_rust::Direction),
        Duration(::prisma_client_rust::Direction),
        IsMeal(::prisma_client_rust::Direction),
        ShiftId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::StartDateTime(direction) => (
                    start_date_time::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::EndDateTime(direction) => (
                    end_date_time::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Duration(direction) => (
                    duration::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::IsMeal(direction) => (
                    is_meal::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ShiftId(direction) => (
                    shift_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        StartDateTime(_prisma::read_filters::StringFilter),
        EndDateTime(_prisma::read_filters::StringFilter),
        Duration(_prisma::read_filters::StringFilter),
        IsMeal(_prisma::read_filters::BoolFilter),
        ShiftId(_prisma::read_filters::StringFilter),
        ShiftIs(Vec<super::shift::WhereParam>),
        ShiftIsNot(Vec<super::shift::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::StartDateTime(value) => (start_date_time::NAME, value.into()),
                Self::EndDateTime(value) => (end_date_time::NAME, value.into()),
                Self::Duration(value) => (duration::NAME, value.into()),
                Self::IsMeal(value) => (is_meal::NAME, value.into()),
                Self::ShiftId(value) => (shift_id::NAME, value.into()),
                Self::ShiftIs(where_params) => (
                    shift::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ShiftIsNot(where_params) => (
                    shift::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(start_date_time::NAME),
                ::prisma_client_rust::sel(end_date_time::NAME),
                ::prisma_client_rust::sel(duration::NAME),
                ::prisma_client_rust::sel(is_meal::NAME),
                ::prisma_client_rust::sel(shift_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            id: String,
            start_date_time: String,
            end_date_time: String,
            duration: String,
            is_meal: bool,
            shift: super::shift::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                id::set(id),
                start_date_time::set(start_date_time),
                end_date_time::set(end_date_time),
                duration::set(duration),
                is_meal::set(is_meal),
                shift::connect(shift),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            id: String,
            start_date_time: String,
            end_date_time: String,
            duration: String,
            is_meal: bool,
            shift_id: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                id::set(id),
                start_date_time::set(start_date_time),
                end_date_time::set(end_date_time),
                duration::set(duration),
                is_meal::set(is_meal),
                shift_id::set(shift_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, String, String, bool, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(
                        id,
                        start_date_time,
                        end_date_time,
                        duration,
                        is_meal,
                        shift_id,
                        mut _params,
                    )| {
                        _params.extend([
                            id::set(id),
                            start_date_time::set(start_date_time),
                            end_date_time::set(end_date_time),
                            duration::set(duration),
                            is_meal::set(is_meal),
                            shift_id::set(shift_id),
                        ]);
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (id, start_date_time, end_date_time, duration, is_meal, shift, mut _params): (
                String,
                String,
                String,
                String,
                bool,
                super::shift::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                id::set(id),
                start_date_time::set(start_date_time),
                end_date_time::set(end_date_time),
                duration::set(duration),
                is_meal::set(is_meal),
                shift::connect(shift),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod _prisma {
    pub struct PrismaClientBuilder {
        url: Option<String>,
        action_notifier: ::prisma_client_rust::ActionNotifier,
    }
    impl PrismaClientBuilder {
        fn new() -> Self {
            Self {
                url: None,
                action_notifier: ::prisma_client_rust::ActionNotifier::new(),
            }
        }
        pub fn with_url(mut self, url: String) -> Self {
            self.url = Some(url);
            self
        }
        pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
            let internals = ::prisma_client_rust::PrismaClientInternals::new(
                self.url,
                self.action_notifier,
                super::DATAMODEL_STR,
            )
            .await?;
            Ok(PrismaClient(internals))
        }
    }
    pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub fn _builder() -> PrismaClientBuilder {
            PrismaClientBuilder::new()
        }
        pub fn _query_raw<T: ::prisma_client_rust::Data>(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub fn _execute_raw(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub async fn _batch<
            'batch,
            T: ::prisma_client_rust::BatchContainer<'batch, Marker>,
            Marker,
        >(
            &self,
            queries: T,
        ) -> ::prisma_client_rust::Result<
            <T as ::prisma_client_rust::BatchContainer<'batch, Marker>>::ReturnType,
        > {
            ::prisma_client_rust::batch(queries, &self.0).await
        }
        pub fn _transaction(&self) -> ::prisma_client_rust::TransactionBuilder<Self> {
            ::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
        }
        pub fn user(&self) -> super::user::Actions {
            super::user::Actions { client: &self.0 }
        }
        pub fn organization(&self) -> super::organization::Actions {
            super::organization::Actions { client: &self.0 }
        }
        pub fn user_role(&self) -> super::user_role::Actions {
            super::user_role::Actions { client: &self.0 }
        }
        pub fn location(&self) -> super::location::Actions {
            super::location::Actions { client: &self.0 }
        }
        pub fn team(&self) -> super::team::Actions {
            super::team::Actions { client: &self.0 }
        }
        pub fn schedule(&self) -> super::schedule::Actions {
            super::schedule::Actions { client: &self.0 }
        }
        pub fn shift(&self) -> super::shift::Actions {
            super::shift::Actions { client: &self.0 }
        }
        pub fn r#break(&self) -> super::r#break::Actions {
            super::r#break::Actions { client: &self.0 }
        }
    }
    impl ::prisma_client_rust::PrismaClient for PrismaClient {
        fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
            &self.0
        }
        fn internals_mut(&mut self) -> &mut ::prisma_client_rust::PrismaClientInternals {
            &mut self.0
        }
        fn with_tx_id(&self, tx_id: Option<::prisma_client_rust::query_core::TxId>) -> Self {
            Self(self.0.with_tx_id(tx_id))
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum BreakScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "start_date_time")]
        StartDateTime,
        #[serde(rename = "end_date_time")]
        EndDateTime,
        #[serde(rename = "duration")]
        Duration,
        #[serde(rename = "is_meal")]
        IsMeal,
        #[serde(rename = "shift_id")]
        ShiftId,
    }
    impl ToString for BreakScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::StartDateTime => "start_date_time".to_string(),
                Self::EndDateTime => "end_date_time".to_string(),
                Self::Duration => "duration".to_string(),
                Self::IsMeal => "is_meal".to_string(),
                Self::ShiftId => "shift_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum LocationScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "email")]
        Email,
        #[serde(rename = "phone")]
        Phone,
        #[serde(rename = "street")]
        Street,
        #[serde(rename = "city")]
        City,
        #[serde(rename = "state")]
        State,
        #[serde(rename = "country")]
        Country,
        #[serde(rename = "postcode")]
        Postcode,
        #[serde(rename = "organization_id")]
        OrganizationId,
    }
    impl ToString for LocationScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Name => "name".to_string(),
                Self::Email => "email".to_string(),
                Self::Phone => "phone".to_string(),
                Self::Street => "street".to_string(),
                Self::City => "city".to_string(),
                Self::State => "state".to_string(),
                Self::Country => "country".to_string(),
                Self::Postcode => "postcode".to_string(),
                Self::OrganizationId => "organization_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum OrganizationScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "email")]
        Email,
        #[serde(rename = "phone")]
        Phone,
    }
    impl ToString for OrganizationScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Name => "name".to_string(),
                Self::Email => "email".to_string(),
                Self::Phone => "phone".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum QueryMode {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "insensitive")]
        Insensitive,
    }
    impl ToString for QueryMode {
        fn to_string(&self) -> String {
            match self {
                Self::Default => "default".to_string(),
                Self::Insensitive => "insensitive".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum ScheduleScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "team_id")]
        TeamId,
        #[serde(rename = "start_date")]
        StartDate,
        #[serde(rename = "end_date")]
        EndDate,
    }
    impl ToString for ScheduleScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::TeamId => "team_id".to_string(),
                Self::StartDate => "start_date".to_string(),
                Self::EndDate => "end_date".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum ShiftScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "assigned_to")]
        AssignedTo,
        #[serde(rename = "start_date_time")]
        StartDateTime,
        #[serde(rename = "end_date_time")]
        EndDateTime,
        #[serde(rename = "duration")]
        Duration,
        #[serde(rename = "is_open")]
        IsOpen,
        #[serde(rename = "is_close")]
        IsClose,
        #[serde(rename = "is_double")]
        IsDouble,
        #[serde(rename = "schedule_id")]
        ScheduleId,
    }
    impl ToString for ShiftScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::AssignedTo => "assigned_to".to_string(),
                Self::StartDateTime => "start_date_time".to_string(),
                Self::EndDateTime => "end_date_time".to_string(),
                Self::Duration => "duration".to_string(),
                Self::IsOpen => "is_open".to_string(),
                Self::IsClose => "is_close".to_string(),
                Self::IsDouble => "is_double".to_string(),
                Self::ScheduleId => "schedule_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TeamScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "location_id")]
        LocationId,
        #[serde(rename = "name")]
        Name,
    }
    impl ToString for TeamScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::LocationId => "location_id".to_string(),
                Self::Name => "name".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "ReadUncommitted")]
        ReadUncommitted,
        #[serde(rename = "ReadCommitted")]
        ReadCommitted,
        #[serde(rename = "RepeatableRead")]
        RepeatableRead,
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::ReadUncommitted => "ReadUncommitted".to_string(),
                Self::ReadCommitted => "ReadCommitted".to_string(),
                Self::RepeatableRead => "RepeatableRead".to_string(),
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    impl ::prisma_client_rust::TransactionIsolationLevel for TransactionIsolationLevel {}
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum UserRoleScalarFieldEnum {
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "organization_id")]
        OrganizationId,
        #[serde(rename = "role")]
        Role,
    }
    impl ToString for UserRoleScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::UserId => "user_id".to_string(),
                Self::OrganizationId => "organization_id".to_string(),
                Self::Role => "role".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum UserScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "first_name")]
        FirstName,
        #[serde(rename = "last_name")]
        LastName,
        #[serde(rename = "phone")]
        Phone,
        #[serde(rename = "email")]
        Email,
        #[serde(rename = "team_id")]
        TeamId,
    }
    impl ToString for UserScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::FirstName => "first_name".to_string(),
                Self::LastName => "last_name".to_string(),
                Self::Phone => "phone".to_string(),
                Self::Email => "email".to_string(),
                Self::TeamId => "team_id".to_string(),
            }
        }
    }
    pub mod read_filters {
        #[derive(Clone)]
        pub enum StringFilter {
            Equals(String),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(super::super::QueryMode),
            Not(String),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Mode(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "mode".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum StringNullableFilter {
            Equals(Option<String>),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(super::super::QueryMode),
            Not(Option<String>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringNullableFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Mode(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "mode".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum BoolFilter {
            Equals(bool),
            Not(bool),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BoolFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Boolean(value),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum RoleFilter {
            Equals(super::super::Role),
            InVec(Vec<super::super::Role>),
            NotInVec(Vec<super::super::Role>),
            Not(super::super::Role),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for RoleFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                }
            }
        }
    }
}
pub use _prisma::*;
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum Role {
    #[serde(rename = "OrganizationAdmin")]
    OrganizationAdmin,
    #[serde(rename = "LocationAdmin")]
    LocationAdmin,
    #[serde(rename = "TeamAdmin")]
    TeamAdmin,
    #[serde(rename = "TeamMember")]
    TeamMember,
}
impl ToString for Role {
    fn to_string(&self) -> String {
        match self {
            Self::OrganizationAdmin => "OrganizationAdmin".to_string(),
            Self::LocationAdmin => "LocationAdmin".to_string(),
            Self::TeamAdmin => "TeamAdmin".to_string(),
            Self::TeamMember => "TeamMember".to_string(),
        }
    }
}
